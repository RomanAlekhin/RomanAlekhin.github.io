/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return App; });\n/* harmony import */ var _Charts_Chart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Charts/Chart */ \"./src/Charts/Chart.js\");\n/* harmony import */ var _Data_DataProvider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Data/DataProvider */ \"./src/Data/DataProvider.js\");\n/* harmony import */ var _ApplicationModes_ModeSwitcher__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ApplicationModes/ModeSwitcher */ \"./src/ApplicationModes/ModeSwitcher.js\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./constants */ \"./src/constants.js\");\n\n\n // import { getShortDate } from './Utils/dateFormaters';\n\n\nclass App {\n  init() {\n    this.modeSwitcher = new _ApplicationModes_ModeSwitcher__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, document.body, document.getElementById('mode-switcher')); // Initialize charts.\n\n    this.charts = [new _Charts_Chart__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, document.getElementById('chart1'), 'Followers', _constants__WEBPACK_IMPORTED_MODULE_3__[\"CHART_TYPES\"].LINE_CHART, 1), new _Charts_Chart__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, document.getElementById('chart2'), 'Interactions', _constants__WEBPACK_IMPORTED_MODULE_3__[\"CHART_TYPES\"].DOUBLE_AXIS_LINE_CHART, 2), new _Charts_Chart__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, document.getElementById('chart3'), 'Messages', _constants__WEBPACK_IMPORTED_MODULE_3__[\"CHART_TYPES\"].STACKED_BAR_CHART, 3), new _Charts_Chart__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, document.getElementById('chart4'), 'Views', _constants__WEBPACK_IMPORTED_MODULE_3__[\"CHART_TYPES\"].DAILY_BAR_CHART, 4), new _Charts_Chart__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this, document.getElementById('chart5'), 'Apps', _constants__WEBPACK_IMPORTED_MODULE_3__[\"CHART_TYPES\"].PERCENTAGE_STACKED_AREA_CHART, 5) // new Chart(this, document.getElementById('chartPie'))\n    ];\n    this.dataProvider = new _Data_DataProvider__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n  }\n\n  loadData() {\n    for (let i = 0; i < 5; i++) {\n      this.dataProvider.loadOverviewData(i + 1).then(data => {\n        this.charts[i].attachData(data);\n      });\n    } // // Data for Pie chart.\n    // this.dataProvider.loadOverviewData(5)\n    //     .then(data => this.charts[5].attachData(data));\n\n\n    this.timestampLabels = {};\n  }\n\n  reinit(dataId, chartId) {\n    this.dataProvider.loadOverviewData(dataId).then(data => {\n      this.charts[chartId].attachData(data);\n    });\n  }\n\n  adjustChartsToScreen() {\n    this.charts.forEach(chart => chart.onAdjustToScreen());\n  }\n\n}\n\n//# sourceURL=webpack:///./src/App.js?");

/***/ }),

/***/ "./src/ApplicationModes/ModeSwitcher.js":
/*!**********************************************!*\
  !*** ./src/ApplicationModes/ModeSwitcher.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ModeSwitcher; });\n/* harmony import */ var _modesConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modesConfig */ \"./src/ApplicationModes/modesConfig.js\");\n\nclass ModeSwitcher {\n  constructor(app, body, button) {\n    this.app = app;\n    this.body = body;\n    this.button = button;\n\n    button.onclick = () => this.applyMode(this.getAnotherMode());\n\n    this.applyMode(_modesConfig__WEBPACK_IMPORTED_MODULE_0__[\"default\"].day); // Use this mode by default\n  }\n\n  applyMode(newMode) {\n    const {\n      button\n    } = this;\n    this.mode = newMode;\n    const oldMode = this.getAnotherMode();\n    button.innerHTML = `Switch to ${oldMode.title}`;\n    const elementsToToggleClass = document.querySelectorAll('.theme');\n    Object.values(elementsToToggleClass).forEach(e => {\n      e.classList.remove(oldMode.className);\n      e.classList.add(newMode.className);\n    });\n    if (this.app.charts) this.app.charts.forEach(c => c.update());\n  }\n\n  getAnotherMode() {\n    return this.mode === _modesConfig__WEBPACK_IMPORTED_MODULE_0__[\"default\"].day ? _modesConfig__WEBPACK_IMPORTED_MODULE_0__[\"default\"].night : _modesConfig__WEBPACK_IMPORTED_MODULE_0__[\"default\"].day;\n  }\n\n  getMode() {\n    return this.mode.id;\n  }\n\n  getCurrentModeClassName() {\n    return this.mode.className;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/ApplicationModes/ModeSwitcher.js?");

/***/ }),

/***/ "./src/ApplicationModes/modesConfig.js":
/*!*********************************************!*\
  !*** ./src/ApplicationModes/modesConfig.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  day: {\n    id: 'day',\n    title: 'Day Mode',\n    className: 'theme-light'\n  },\n  night: {\n    id: 'night',\n    title: 'Night Mode',\n    className: 'theme-dark'\n  }\n});\n\n//# sourceURL=webpack:///./src/ApplicationModes/modesConfig.js?");

/***/ }),

/***/ "./src/Charts/Animator.js":
/*!********************************!*\
  !*** ./src/Charts/Animator.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Animator; });\nclass Animator {\n  constructor(chart) {\n    this.chart = chart;\n    this.animations = {};\n    this.updateAnimationsBound = this.updateAnimations.bind(this);\n  }\n\n  startAnimation(id, updateCallback, from, to, duration, shouldRerenderMain, shouldRerenderSlider, onEndCallback, fixedFrames = null) {\n    this.animations[id] = {\n      updateCallback,\n      from,\n      to,\n      delta: to - from,\n      start: performance.now(),\n      duration,\n      shouldRerenderMain,\n      shouldRerenderSlider,\n      onEndCallback,\n      fixedFrames,\n      fixedFramesLeft: fixedFrames\n    };\n  }\n\n  updateAnimations(time) {\n    let shouldRerenderMain = this.chart.mainWindow.shouldRerender;\n    let shouldRerenderSlider = this.chart.slider.shouldRerender; /// DEBUG performance;\n\n    let mainrerenderes = [];\n    Object.entries(this.animations).forEach(([id, anim]) => {\n      if (anim.shouldRerenderMain) shouldRerenderMain = true; /// DEBUG performance;\n\n      if (anim.shouldRerenderMain) mainrerenderes.push(id);\n      if (anim.shouldRerenderSlider) shouldRerenderSlider = true;\n      let timeFraction;\n\n      if (!anim.fixedFrames) {\n        timeFraction = (time - anim.start) / anim.duration;\n      } else {\n        timeFraction = (anim.fixedFrames - anim.fixedFramesLeft + 1) / anim.fixedFrames;\n        anim.fixedFramesLeft -= 1;\n      }\n\n      if (timeFraction > 1) timeFraction = 1;\n      const newValue = anim.from + anim.delta * timeFraction;\n\n      if (timeFraction > 1) {}\n\n      if (timeFraction < 0) {}\n\n      anim.updateCallback(newValue, timeFraction);\n\n      if (timeFraction >= 1) {\n        if (anim.onEndCallback) anim.onEndCallback();\n        delete this.animations[id];\n      }\n    });\n    requestAnimationFrame(this.updateAnimationsBound);\n\n    if (shouldRerenderMain) {\n      this.chart.mainWindow.render();\n    }\n\n    if (shouldRerenderSlider) {\n      this.chart.slider.render();\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/Animator.js?");

/***/ }),

/***/ "./src/Charts/AxisManager.js":
/*!***********************************!*\
  !*** ./src/Charts/AxisManager.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AxisManager; });\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ \"./src/Settings/index.js\");\n/* harmony import */ var _Render_chartRenderUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Render/chartRenderUtils */ \"./src/Charts/Render/chartRenderUtils.js\");\n/* harmony import */ var _ChartArea__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ChartArea */ \"./src/Charts/ChartArea.js\");\n/* harmony import */ var _Settings_mainWindow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Settings/mainWindow */ \"./src/Settings/mainWindow.js\");\n\n\n\n\nconst DEFAULT_AXES_COUNT = 6;\nconst PERCENTAGE_AXES_COUNT = 5;\nconst LAST_AXIS_OFFSET = 0.25;\nconst RESCALE_RATE = 0.10;\nconst RESCALE_ANIM_DURATION_LINE = 150;\nconst RESCALE_ANIM_DURATION_STACKED = 300;\nconst AXIS_ANIM_DURATION = 150;\n\nconst calculateNewAxes = (min, max, count, percentage) => {\n  const newAxes = {};\n  const delta = (max - min) / (count - 1 + (!percentage ? LAST_AXIS_OFFSET : 0));\n\n  for (let i = 0; i < count; i++) {\n    newAxes[min + delta * i] = 0;\n  }\n\n  return newAxes;\n};\n\nclass AxisManager {\n  constructor(chart, chartArea, idForAnimator) {\n    this.chart = chart;\n    this.chartArea = chartArea;\n    this.idForAnimator = idForAnimator;\n  }\n\n  attachData(data) {\n    this.data = data;\n    this.axes = {};\n    this.axesCount = data.options.percentage ? PERCENTAGE_AXES_COUNT : DEFAULT_AXES_COUNT;\n\n    if (data.options.doubleAxis) {\n      this.altAxes = {};\n      this.altChartArea = new _ChartArea__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.chart, this.chart.mainWindow.canvas, _Settings_mainWindow__WEBPACK_IMPORTED_MODULE_3__[\"padding\"]);\n      this.chart.mainWindow.dataRenderer.altChartArea = this.altChartArea;\n    } else {\n      delete this.altAxes;\n      delete this.altChartArea;\n    }\n\n    this.init();\n  }\n\n  init() {\n    const {\n      startTick,\n      endTick\n    } = this.chart.slider.getSelectedTicks();\n    const {\n      min,\n      max\n    } = this.data.getMinMaxValues(startTick, endTick);\n    this.min = min;\n    this.max = max;\n    this.renderedMinMax = {\n      min: this.min,\n      max: this.max\n    }; // this property is used for render\n\n    if (this.data.options.doubleAxis) {\n      this.altMinMax = this.data.getMinMaxValuesForAlternateAxis(startTick, endTick, true);\n      this.altRenderedMinMax = {\n        min: this.altMinMax.min,\n        max: this.altMinMax.max\n      }; // this property is used for render\n    }\n\n    const initialAxes = calculateNewAxes(min, max, this.axesCount, this.data.options.percentage);\n    Object.keys(initialAxes).forEach(val => {\n      this.axes[val] = 1;\n    });\n\n    if (this.data.options.doubleAxis) {\n      const initialAltAxes = calculateNewAxes(this.altMinMax.min, this.altMinMax.max, this.axesCount, this.data.options.percentage);\n      Object.keys(initialAltAxes).forEach(val => {\n        this.altAxes[val] = 1;\n      });\n    }\n\n    this.chartArea.updateSizing({\n      min,\n      max\n    }, this.chart.slider.selection);\n    if (this.altChartArea) this.altChartArea.updateSizing({\n      min: this.altMinMax.min,\n      max: this.altMinMax.max\n    }, this.chart.slider.selection);\n  } // Events\n\n\n  onSliderChanged() {\n    const {\n      startTick,\n      endTick\n    } = this.chart.slider.getSelectedTicks();\n    const {\n      min: newMin,\n      max: newMax\n    } = this.data.getMinMaxValues(startTick, endTick);\n    const deltaMax = Math.abs(this.max - newMax) / (this.max - this.min);\n    const deltaMin = Math.abs(this.min - newMin) / (this.max - this.min);\n\n    if (deltaMax + deltaMin >= RESCALE_RATE) {\n      this.min = newMin;\n      this.max = newMax;\n      this.animateUpdateMinMax(newMin, newMax);\n    }\n\n    if (this.data.options.doubleAxis) {\n      const {\n        min: newAltMin,\n        max: newAltMax\n      } = this.data.getMinMaxValuesForAlternateAxis(startTick, endTick);\n      const deltaAltMax = Math.abs(this.altMinMax.max - newAltMax) / (this.altMinMax.max - this.altMinMax.min);\n      const deltaAltMin = Math.abs(this.altMinMax.min - newAltMin) / (this.altMinMax.max - this.altMinMax.min);\n\n      if (deltaAltMax + deltaAltMin >= RESCALE_RATE) {\n        this.altMinMax.min = newAltMin;\n        this.altMinMax.max = newAltMax;\n        this.animateUpdateAltMinMax(newAltMin, newAltMax);\n      }\n    }\n\n    this.chart.mainWindow.shouldRerender = true;\n  }\n\n  resizeChartAreas() {\n    this.chartArea.updateSizing({\n      min: this.renderedMinMax.min,\n      max: this.renderedMinMax.max\n    }, this.chart.slider.selection);\n\n    if (this.data.options.doubleAxis) {\n      this.altChartArea.updateSizing({\n        min: this.altRenderedMinMax.min,\n        max: this.altRenderedMinMax.max\n      }, this.chart.slider.selection);\n    }\n  }\n\n  calcZoomInAnimValues() {\n    const {\n      xScale,\n      xOffset\n    } = this.chartArea;\n    const xOffsetNew = xOffset - this.chartArea.canvas.width * 13;\n    this.targSizing = {\n      xScale: xScale * 5,\n      xOffset: xOffsetNew\n    };\n    this.initSizing = {\n      xScale,\n      xOffset\n    };\n\n    if (this.altChartArea) {\n      const {\n        xScale: xScaleAlt,\n        xOffset: xOffsetAlt\n      } = this.altChartArea;\n      const xOffsetAltNew = xOffsetAlt - this.altChartArea.canvas.width * 13;\n      this.targSizingAlt = {\n        xScale: xScaleAlt * 5,\n        xOffset: xOffsetAltNew\n      };\n      this.initSizingAlt = {\n        xScale: xScaleAlt,\n        xOffset: xOffsetAlt\n      };\n    }\n  }\n\n  renderAxes() {\n    const {\n      doubleAxis,\n      percentage\n    } = this.data.options;\n    Object(_Render_chartRenderUtils__WEBPACK_IMPORTED_MODULE_1__[\"renderAxes\"])(this.axes, this.chart.mainWindow.canvas, this.chartArea, percentage, doubleAxis ? this.data.valueDatasets[0].color : undefined, false, doubleAxis ? this.data.valueDatasets[0].presence : undefined);\n\n    if (doubleAxis) {\n      Object(_Render_chartRenderUtils__WEBPACK_IMPORTED_MODULE_1__[\"renderAxes\"])(this.altAxes, this.chart.mainWindow.canvas, this.altChartArea, percentage, this.data.valueDatasets[1].color, true, this.data.valueDatasets[1].presence);\n    }\n  }\n\n  animateUpdateMinMax(newMin, newMax) {\n    this.min = newMin;\n    this.max = newMax;\n    const {\n      stacked\n    } = this.data.options;\n    this.chart.animator.startAnimation(`${this.idForAnimator}_main_min`, newValue => {\n      this.renderedMinMax.min = newValue;\n    }, this.renderedMinMax.min, newMin, stacked ? RESCALE_ANIM_DURATION_STACKED : RESCALE_ANIM_DURATION_LINE, true, false);\n    this.chart.animator.startAnimation(`${this.idForAnimator}_main_max`, newValue => {\n      this.renderedMinMax.max = newValue;\n    }, this.renderedMinMax.max, newMax, stacked ? RESCALE_ANIM_DURATION_STACKED : RESCALE_ANIM_DURATION_LINE, true, false);\n    this.animateAxesUpdate();\n  }\n\n  animateUpdateAltMinMax(newAltMin, newAltMax) {\n    this.altMinMax = {\n      min: newAltMin,\n      max: newAltMax\n    };\n    const {\n      stacked\n    } = this.data.options;\n    this.chart.animator.startAnimation(`${this.idForAnimator}_alt_min`, newValue => {\n      this.altRenderedMinMax.min = newValue;\n    }, this.altRenderedMinMax.min, newAltMin, stacked ? RESCALE_ANIM_DURATION_STACKED : RESCALE_ANIM_DURATION_LINE, true, false);\n    this.chart.animator.startAnimation(`${this.idForAnimator}_alt_max`, newValue => {\n      this.altRenderedMinMax.max = newValue;\n    }, this.altRenderedMinMax.max, newAltMax, stacked ? RESCALE_ANIM_DURATION_STACKED : RESCALE_ANIM_DURATION_LINE, true, false);\n    this.animateAltAxesUpdate();\n  }\n\n  animateAxesUpdate() {\n    if (!this.data.options.percentage) {\n      const newAxes = calculateNewAxes(this.min, this.max, this.axesCount); // Remove old axes.\n\n      Object.entries(this.axes).forEach(([val, currentPresence]) => {\n        if (newAxes[val] === undefined) {\n          this.chart.animator.startAnimation(`${this.idForAnimator}_${val}`, newValue => {\n            this.axes[val] = newValue;\n          }, currentPresence, 0, AXIS_ANIM_DURATION, true, false, () => {\n            delete this.axes[val];\n          });\n        }\n      }); // Add new axes.\n\n      Object.keys(newAxes).forEach(val => {\n        if (this.axes[val] === undefined) this.axes[val] = 0;\n\n        if (this.axes[val] < 1) {\n          this.chart.animator.startAnimation(`${this.idForAnimator}_${val}`, newValue => {\n            this.axes[val] = newValue;\n          }, 0, 1, AXIS_ANIM_DURATION, true, false);\n        }\n      });\n    }\n  }\n\n  animateAltAxesUpdate() {\n    if (!this.data.options.percentage) {\n      const newAxes = calculateNewAxes(this.altMinMax.min, this.altMinMax.max, this.axesCount); // Remove old axes.\n\n      Object.entries(this.altAxes).forEach(([val, currentPresence]) => {\n        if (newAxes[val] === undefined) {\n          this.chart.animator.startAnimation(`${this.idForAnimator}_${val}`, newValue => {\n            this.altAxes[val] = newValue;\n          }, currentPresence, 0, AXIS_ANIM_DURATION, true, false, () => {\n            delete this.altAxes[val];\n          });\n        }\n      }); // Add new axes.\n\n      Object.keys(newAxes).forEach(val => {\n        if (this.altAxes[val] === undefined) this.altAxes[val] = 0;\n\n        if (this.altAxes[val] < 1) {\n          this.chart.animator.startAnimation(`${this.idForAnimator}_${val}`, newValue => {\n            this.altAxes[val] = newValue;\n          }, 0, 1, AXIS_ANIM_DURATION, true, false);\n        }\n      });\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/AxisManager.js?");

/***/ }),

/***/ "./src/Charts/Chart.js":
/*!*****************************!*\
  !*** ./src/Charts/Chart.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Chart; });\n/* harmony import */ var _Animator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Animator */ \"./src/Charts/Animator.js\");\n/* harmony import */ var _AxisManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AxisManager */ \"./src/Charts/AxisManager.js\");\n/* harmony import */ var _DataButtons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./DataButtons */ \"./src/Charts/DataButtons.js\");\n/* harmony import */ var _MainWindow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MainWindow */ \"./src/Charts/MainWindow.js\");\n/* harmony import */ var _Slider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Slider */ \"./src/Charts/Slider.js\");\n\n\n\n\n\nconst STACKED_ANIM_DURATION = 300;\nconst LINE_ANIM_DURATION = 150;\nclass Chart {\n  constructor(app, node, name, chartType, relatedDataId) {\n    this.app = app;\n    this.node = node;\n    this.name = name;\n    this.chartType = chartType;\n    this.relatedDataId = relatedDataId;\n    this.isZoomed = false;\n    this.animator = new _Animator__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\n    this.mainWindow = new _MainWindow__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this);\n    this.slider = new _Slider__WEBPACK_IMPORTED_MODULE_4__[\"default\"](this);\n    this.dataButtons = new _DataButtons__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    this.axisManager = new _AxisManager__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this, this.mainWindow.chartArea, 'main_axes');\n    if (!chartType.sliderEnabled) this.slider.disable();\n    if (!chartType.buttonsEnabled) this.dataButtons.disable();\n    this.zoomer = node.querySelector('.zoom');\n\n    if (this.zoomer) {\n      this.zoomer.onclick = () => {\n        if (!this.isZoomed) {\n          const tick = this.mainWindow.dataRenderer.selectedTick || this.slider.getSelectedTicks().endTick;\n          this.enterZoomedMode(this.data.axisDataset.values[tick]);\n          this.mainWindow.hidePopup();\n        } else {\n          this.exitZoomedMode();\n        }\n      };\n    }\n\n    this.onAdjustToScreen();\n  }\n\n  attachData(data) {\n    if (!data) return;\n    this.data = data;\n    data.refreshCache();\n    this.dataButtons.attachDatasets(data.valueDatasets);\n    this.slider.attachData(data);\n    this.axisManager.attachData(data);\n    this.mainWindow.attachData(data);\n    this.update(); // ???? should we make the first render here ???\n\n    requestAnimationFrame(this.animator.updateAnimationsBound);\n  } // Events\n\n\n  onDatasetToggled(dataset) {\n    if (!this.data.valueDatasets.some(d => d.enabled)) {\n      this.dataButtons.shakeButton(dataset);\n      this.dataButtons.forciblyToggleButton(dataset, true);\n      return false;\n    }\n\n    this.animateToggleDataset(dataset);\n    this.data.refreshCache();\n    this.slider.animateUpdateMinMax();\n    const {\n      startTick,\n      endTick\n    } = this.slider.getSelectedTicks();\n    const {\n      min,\n      max\n    } = this.data.getMinMaxValues(startTick, endTick);\n    this.axisManager.animateUpdateMinMax(min, max);\n    return true;\n  }\n\n  onDatasetPrioritized(dataset) {\n    if (this.data.valueDatasets.length <= 1) {\n      this.shake();\n      this.dataButtons.forciblyToggleButton(dataset, true);\n      return;\n    }\n\n    this.data.valueDatasets.forEach(d => {\n      this.dataButtons.forciblyToggleButton(d, d === dataset);\n      this.animateToggleDataset(d);\n    });\n    this.data.refreshCache();\n    this.slider.animateUpdateMinMax();\n    const {\n      startTick,\n      endTick\n    } = this.slider.getSelectedTicks();\n    const {\n      min,\n      max\n    } = this.data.getMinMaxValues(startTick, endTick);\n    this.axisManager.animateUpdateMinMax(min, max);\n  }\n\n  onSliderChanged() {\n    this.axisManager.onSliderChanged();\n    this.mainWindow.timeLabelsManager.onResize();\n  }\n\n  onAdjustToScreen() {\n    this.mainWindow.onAdjustToScreen();\n    this.slider.onAdjustToScreen();\n  }\n\n  update() {\n    this.mainWindow.render();\n    this.slider.render();\n  } // Animations\n\n\n  animateToggleDataset(dataset) {\n    const animId = `data_presence_${dataset.id}`;\n    const from = dataset.presence;\n    const to = dataset.enabled ? 1 : 0;\n    const duration = dataset.type === 'line' ? LINE_ANIM_DURATION : STACKED_ANIM_DURATION;\n    this.animator.startAnimation(animId, newValue => {\n      dataset.presence = newValue;\n      if (this.data.options.stacked) this.data.refreshCache();\n    }, from, to, duration, true, true);\n  }\n\n  enterZoomedMode(timestamp) {\n    this.overviewData = this.data;\n    window.app.dataProvider.loadDetailedData(this.relatedDataId, timestamp).then(data => {\n      this.zoomer.innerHTML = 'zoom out';\n      this.isZoomed = true;\n      this.attachData(data);\n    });\n  }\n\n  exitZoomedMode() {\n    this.isZoomed = false;\n    this.zoomer.innerHTML = 'zoom in';\n    this.attachData(this.overviewData);\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/Chart.js?");

/***/ }),

/***/ "./src/Charts/ChartArea.js":
/*!*********************************!*\
  !*** ./src/Charts/ChartArea.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ChartArea; });\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Settings */ \"./src/Settings/index.js\");\n/* harmony import */ var _Settings_popupWindow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Settings/popupWindow */ \"./src/Settings/popupWindow.js\");\n\n // Represents area for chart.\n\nclass ChartArea {\n  constructor(chart, canvas, padding = {\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0\n  }) {\n    this.chart = chart;\n    this.canvas = canvas;\n    this.padding = padding;\n  }\n\n  updateSizing(valuesRange, selection) {\n    const {\n      canvas,\n      chart,\n      padding\n    } = this;\n    const intervalsBetweenTicks = chart.data.totalTicks - 1;\n    this.xScale = (canvas.width - padding.left - padding.right) / intervalsBetweenTicks / (selection.to - selection.from);\n    this.xOffset = -selection.from * this.xScale * intervalsBetweenTicks + padding.right;\n    this.yScale = (canvas.height - padding.bottom - padding.top) / (valuesRange.max - valuesRange.min);\n    this.yOffset = valuesRange.max * this.yScale + padding.top;\n\n    if (this.shake) {\n      this.xOffset += this.shake.x;\n      this.yOffset += this.shake.y;\n    }\n  }\n\n  getCanvasPositionForPoint(value, tickIndex) {\n    const {\n      xOffset,\n      xScale,\n      yOffset,\n      yScale\n    } = this;\n    const x = Math.round(tickIndex * xScale + xOffset - this.padding.right);\n    const y = Math.round(yOffset - value * yScale);\n    return {\n      x,\n      y\n    };\n  }\n\n  getCanvasPositionForBar(tickIndex, value) {\n    const {\n      xOffset,\n      xScale,\n      yOffset,\n      yScale,\n      canvas,\n      padding\n    } = this;\n    const x1 = Math.round((tickIndex - 0.5) * xScale + xOffset);\n    const x2 = Math.round((tickIndex + 0.5) * xScale + xOffset);\n    const y = Math.round(yOffset - value * yScale); // TODO - negative values support ???\n\n    const height = canvas.height - padding.bottom - y;\n    return {\n      x1,\n      x2,\n      y,\n      height\n    };\n  }\n\n  getCanvasPositionForStackedValues_BARS(tickIndex, stacked) {\n    const {\n      xOffset,\n      xScale,\n      yOffset,\n      yScale,\n      canvas,\n      padding\n    } = this;\n    const x1 = Math.round((tickIndex - 0.5) * xScale + xOffset);\n    const x2 = Math.round((tickIndex + 0.5) * xScale + xOffset);\n    const bars = {};\n    let prevBarY = null;\n    Object.entries(stacked.values).forEach(([datasetIndex, value]) => {\n      const y = Math.round(yOffset - value * yScale);\n      const height = prevBarY !== null ? prevBarY - y : canvas.height - padding.bottom - y;\n      prevBarY = y; // TODO - check do I really need this\n\n      bars[datasetIndex] = {\n        y,\n        height\n      };\n    });\n    return {\n      x1,\n      x2,\n      bars\n    };\n  }\n\n  getCanvasPositionForStackedPercentageValues(tickIndex, stackedPercentage) {\n    const {\n      xOffset,\n      xScale,\n      yOffset,\n      yScale\n    } = this;\n    const x = Math.round(tickIndex * xScale + xOffset);\n    const ys = {};\n    Object.entries(stackedPercentage.values).forEach(([ind, value]) => {\n      const y = Math.round(yOffset - value * yScale);\n      ys[ind] = y;\n    });\n    return {\n      x,\n      ys\n    };\n  }\n\n  getChartBottomY() {\n    return this.canvas.height - this.padding.bottom;\n  }\n\n  getCanvasPositionForHorizontalAxis(value) {\n    const {\n      canvas,\n      yOffset,\n      yScale\n    } = this;\n    const y = Math.round(yOffset - value * yScale);\n    return {\n      xStart: 0,\n      xEnd: canvas.width,\n      y\n    };\n  }\n\n  getCanvasPositionForValueLabel(value, alternate) {\n    const {\n      yOffset,\n      yScale,\n      padding\n    } = this;\n    const y = Math.round(yOffset - value * yScale + _Settings__WEBPACK_IMPORTED_MODULE_0__[\"chartValueLabelYOffset\"]);\n    return {\n      x: !alternate ? padding.left * 0 : this.canvas.width - padding.right * 0,\n      y\n    };\n  }\n\n  getCanvasPositionForTimestamp(tickIndex) {\n    const {\n      canvas,\n      xOffset,\n      xScale\n    } = this;\n    const x = Math.round(tickIndex * xScale + xOffset + _Settings__WEBPACK_IMPORTED_MODULE_0__[\"chartTimestampXOffset\"]);\n    const y = canvas.height - _Settings__WEBPACK_IMPORTED_MODULE_0__[\"chartTimestampYOffset\"];\n    return {\n      x,\n      y\n    };\n  }\n\n  getTickIndexFromClientXOverCanvas(clientX) {\n    const {\n      canvas,\n      xOffset,\n      xScale\n    } = this;\n    const boundingRect = canvas.getBoundingClientRect();\n    const clientXOverCanvas = (clientX - boundingRect.left + 1) * window.devicePixelRatio;\n    const tickIndex = Math.round((clientXOverCanvas - xOffset) / xScale);\n    return tickIndex;\n  }\n\n  getCanvasPositionForVerticalAxis(tickIndex) {\n    const {\n      canvas,\n      padding,\n      xOffset,\n      xScale\n    } = this;\n    const x = tickIndex * xScale + xOffset;\n    return {\n      x,\n      yStart: 0,\n      yEnd: canvas.height - padding.bottom\n    };\n  }\n\n  getCanvasPositionForPopupWindow(tickIndex, textWidth) {\n    const {\n      canvas,\n      xOffset,\n      xScale\n    } = this;\n    const tickX = tickIndex * xScale + xOffset;\n    const windowWidth = textWidth + _Settings_popupWindow__WEBPACK_IMPORTED_MODULE_1__[\"padding\"] * 2;\n    let x = tickX - windowWidth / 2;\n\n    if (x + windowWidth > canvas.width - _Settings_popupWindow__WEBPACK_IMPORTED_MODULE_1__[\"canvasMinXMargin\"]) {\n      x = canvas.width - _Settings_popupWindow__WEBPACK_IMPORTED_MODULE_1__[\"canvasMinXMargin\"] - windowWidth;\n    }\n\n    if (x < 0) x = _Settings_popupWindow__WEBPACK_IMPORTED_MODULE_1__[\"canvasMinXMargin\"];\n    return {\n      x,\n      y: _Settings_popupWindow__WEBPACK_IMPORTED_MODULE_1__[\"yOffset\"]\n    };\n  }\n\n  getCanvasPositionFromClientOverCanvas(clientX, clientY) {\n    const {\n      canvas\n    } = this;\n    const boundingRect = canvas.getBoundingClientRect();\n    const ratio = window.devicePixelRatio;\n    const clientXOverCanvas = (clientX - boundingRect.left + 1) * ratio;\n    const clientYOverCanvas = (clientY - boundingRect.top + 1) * ratio;\n    return {\n      x: clientXOverCanvas,\n      y: clientYOverCanvas\n    };\n  }\n\n  getCanvasPositionForStackedBar(tickIndex, values) {\n    const {\n      xOffset,\n      xScale,\n      yOffset,\n      yScale,\n      canvas,\n      padding\n    } = this;\n    const x1 = Math.round((tickIndex - 0.5) * xScale + xOffset);\n    const x2 = Math.round((tickIndex + 0.5) * xScale + xOffset);\n    const bars = {};\n    let prevBarY = null;\n    Object.entries(values).forEach(([datasetIndex, stacked]) => {\n      if (prevBarY === null) {\n        const y = Math.round(yOffset - stacked.sum * yScale);\n        prevBarY = y;\n        const height = canvas.height - padding.bottom - y;\n        bars[datasetIndex] = {\n          y,\n          height\n        };\n      } else {\n        const y = Math.round(yOffset - stacked.sum * yScale);\n        const height = prevBarY - y;\n        prevBarY = y;\n        bars[datasetIndex] = {\n          y,\n          height\n        };\n      }\n    });\n    return {\n      x1,\n      x2,\n      bars\n    };\n  }\n\n  getCanvasPositionForPieChart(data) {\n    const {\n      canvas,\n      padding\n    } = this;\n    const INITIAL_ANGLE_OFFSET = 30;\n    const RADIUS = 0.3 * Math.min(canvas.width, canvas.height); // padding is ignored here\n\n    const centerX = canvas.width / 2;\n    const centerY = canvas.height / 2;\n\n    const degToRad = deg => deg * (Math.PI / 180);\n\n    const result = {\n      centerX: Math.round(centerX),\n      centerY: Math.round(centerY),\n      radius: RADIUS,\n      slices: {}\n    }; // TODO - inject pixel perfect angles HERE ????\n\n    Object.entries(data).forEach(([dataInd, values]) => {\n      // const startAngle = INITIAL_ANGLE_OFFSET + (values.stackedAnimPercent - values.animatedPercent) / 100 * 360;\n      // const angle = values.animatedPercent / 100 * 360;\n      const endAngle = INITIAL_ANGLE_OFFSET + values.stackedAnimPercent / 100 * 360;\n      const startAngle = endAngle - values.animatedPercent / 100 * 360;\n      const x1 = Math.round(centerX + Math.cos(degToRad(startAngle)));\n      const y1 = Math.round(centerY + Math.sin(degToRad(startAngle))); // const x2 = Math.round(centerX + Math.cos(degToRad(endAngle)));\n      // const y2 = Math.round(centerY + Math.sin(degToRad(endAngle)));\n\n      result.slices[dataInd] = {\n        startAngle: degToRad(startAngle),\n        endAngle: degToRad(endAngle),\n        x1,\n        y1\n      };\n    });\n    return result;\n  } // clear() {\n  //     this.canvas.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);\n  // }\n\n\n}\n\n//# sourceURL=webpack:///./src/Charts/ChartArea.js?");

/***/ }),

/***/ "./src/Charts/DataButtons.js":
/*!***********************************!*\
  !*** ./src/Charts/DataButtons.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataButtons; });\nconst createButton = (chartId, dataId, name, color) => {\n  const buttonId = `${chartId}-${dataId}`;\n  const themeClassName = window.app.modeSwitcher.getCurrentModeClassName();\n  return `<div class=\"round on\" style=\"background-color:${color};border-color:${color};\">\n                <input type=\"checkbox\" id=\"${buttonId}\" checked>\n                <label for=\"${buttonId}\" style=\"background-color: ${color}; border-color:${color};\"></label>\n                <div class=\"checkbox_text theme ${themeClassName}\">${name}</div>\n            </div>`;\n};\n\nconst LONG_TAP_TIMEOUT = 600;\n\nconst applyOnStyle = (dataset, button) => {\n  button.querySelector('input').checked = dataset.enabled;\n  const round = button.querySelector('.round');\n  round.classList.remove('off');\n  round.classList.add('on');\n  round.style = `background-color:${dataset.color};border-color:${dataset.color};`;\n  button.querySelector('.checkbox_text').style.color = '#FFFFFF';\n};\n\nconst applyOffStyle = (dataset, button) => {\n  button.querySelector('input').checked = dataset.enabled;\n  const round = button.querySelector('.round');\n  round.classList.remove('on');\n  round.classList.add('off');\n  round.style = `border-color:${dataset.color};`;\n  button.querySelector('.checkbox_text').style.color = dataset.color;\n};\n\nconst handleSimpleClick = (dataset, chart, button) => {\n  dataset.enabled = !dataset.enabled;\n\n  if (chart.onDatasetToggled(dataset)) {\n    pressButton(button);\n\n    if (dataset.enabled) {\n      applyOnStyle(dataset, button);\n    } else {\n      applyOffStyle(dataset, button);\n    }\n  }\n};\n\nconst handleLongTap = (dataset, chart, button) => {\n  console.log('long tap');\n  chart.onDatasetPrioritized(dataset);\n  animateLongTap(button);\n};\n\nconst createDataButton = (dataset, chart, dataButtons) => {\n  const button = document.createElement('div');\n  button.className = 'button-container';\n  button.innerHTML = createButton(chart.node.id, dataset.id, dataset.name, dataset.color);\n  const checkbox = button.querySelector('input');\n  const round = button.querySelector('.round');\n\n  button.ontouchstart = e => {\n    // e.preventDefault();\n    // alert('touch start');\n    // console.log('touch start', dataButtons.ignoreSimpleTouch);\n    dataButtons.longTap = setTimeout(() => {\n      handleLongTap(dataset, chart, button);\n      dataButtons.ignoreSimpleTouch = true;\n    }, LONG_TAP_TIMEOUT);\n  };\n\n  button.ontouchend = e => {\n    // e.preventDefault();\n    // alert('touch end');\n    // console.log('touch end', dataButtons.ignoreSimpleTouch);\n    clearTimeout(dataButtons.longTap);\n  };\n\n  button.ontouchcancel = e => {\n    // e.preventDefault();\n    // alert('touch cancel');\n    // console.log('touch cancel', dataButtons.ignoreSimpleTouch);\n    clearTimeout(dataButtons.longTap);\n  };\n\n  button.ontouchmove = e => {\n    // e.preventDefault();\n    // alert('touch move');\n    // console.log('touch move', dataButtons.ignoreSimpleTouch);\n    clearTimeout(dataButtons.longTap);\n  };\n\n  button.onmousedown = e => {\n    // e.preventDefault();\n    // alert('mouse down');\n    // console.log('mouse down', dataButtons.ignoreSimpleMouseClick);\n    dataButtons.longTap = setTimeout(() => {\n      handleLongTap(dataset, chart, button);\n      dataButtons.ignoreSimpleMouseClick = true;\n    }, LONG_TAP_TIMEOUT);\n  };\n\n  button.onmouseup = e => {\n    // e.preventDefault();\n    // alert('mouse down');\n    // console.log('mouse up', dataButtons.ignoreSimpleMouseClick);\n    clearTimeout(dataButtons.longTap);\n  };\n\n  button.onmouseleave = e => {\n    // e.preventDefault();\n    // alert('mouse leave');\n    // console.log('mouse leave', dataButtons.ignoreSimpleMouseClick);\n    clearTimeout(dataButtons.longTap);\n    if (dataButtons.ignoreSimpleMouseClick) dataButtons.ignoreSimpleMouseClick = false;\n  };\n\n  button.firstChild.onclick = e => {\n    // e.preventDefault();\n    // alert('click');\n    // console.log('click', dataButtons.ignoreSimpleMouseClick, dataButtons.ignoreSimpleTouch);\n    e.preventDefault();\n\n    if (!dataButtons.ignoreSimpleMouseClick && !dataButtons.ignoreSimpleTouch) {\n      clearTimeout(dataButtons.longTap);\n      handleSimpleClick(dataset, chart, button);\n    }\n\n    dataButtons.ignoreSimpleMouseClick = false;\n    dataButtons.ignoreSimpleTouch = false;\n  };\n\n  return button;\n}; // const applyAnimation = (button, anim) => {\n//     const animatedElement = button.querySelector('.round');\n//     animatedElement.classList.remove(anim);\n//     void animatedElement.offsetWidth;\n//     animatedElement.classList.add(anim);\n//     void animatedElement.offsetWidth;\n// }\n\n\nconst pressButton = button => {\n  const animatedElement = button.querySelector('.round');\n  animatedElement.classList.remove('shake');\n  animatedElement.classList.remove('press');\n  animatedElement.classList.remove('longTap');\n  void animatedElement.offsetWidth;\n  animatedElement.classList.add('press');\n};\n\nconst animateLongTap = button => {\n  const animatedElement = button.querySelector('.round');\n  animatedElement.classList.remove('shake');\n  animatedElement.classList.remove('press');\n  animatedElement.classList.remove('longTap'); // void animatedElement.offsetWidth;\n\n  animatedElement.classList.add('longTap');\n};\n\nclass DataButtons {\n  constructor(chart) {\n    this.chart = chart;\n    this.node = chart.node.querySelector('.chart-data-selection');\n  }\n\n  enable() {\n    console.log('dataButtons enabled');\n  }\n\n  disable() {\n    console.log('dataButtons disabled');\n  }\n\n  attachDatasets(datasets) {\n    this.datasets = datasets;\n    const {\n      chart,\n      node\n    } = this;\n\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n\n    this.dataButtons = {};\n    datasets.forEach(dataset => {\n      const button = createDataButton(dataset, chart, this);\n      node.appendChild(button);\n      this.dataButtons[dataset.id] = button;\n    });\n  }\n\n  forciblyToggleButton(dataset, checked) {\n    dataset.enabled = checked;\n\n    if (checked) {\n      applyOnStyle(dataset, this.dataButtons[dataset.id]);\n    } else {\n      applyOffStyle(dataset, this.dataButtons[dataset.id]);\n    }\n  }\n\n  shakeButton(dataset) {\n    const button = this.dataButtons[dataset.id];\n    const animatedElement = button.querySelector('.round');\n    animatedElement.classList.remove('press');\n    animatedElement.classList.remove('shake');\n    animatedElement.classList.remove('longTap');\n    void animatedElement.offsetWidth;\n    animatedElement.classList.add('shake');\n    void animatedElement.offsetWidth;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/DataButtons.js?");

/***/ }),

/***/ "./src/Charts/MainWindow.js":
/*!**********************************!*\
  !*** ./src/Charts/MainWindow.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MainWindow; });\n/* harmony import */ var _ChartArea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChartArea */ \"./src/Charts/ChartArea.js\");\n/* harmony import */ var _Render_DataRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Render/DataRenderer */ \"./src/Charts/Render/DataRenderer.js\");\n/* harmony import */ var _Render_TimeLabelsManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Render/TimeLabelsManager */ \"./src/Charts/Render/TimeLabelsManager.js\");\n/* harmony import */ var _Settings_mainWindow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Settings/mainWindow */ \"./src/Settings/mainWindow.js\");\n/* harmony import */ var _Utils_dateFormaters__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Utils/dateFormaters */ \"./src/Utils/dateFormaters.js\");\n/* harmony import */ var _Utils_numberUtils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Utils/numberUtils */ \"./src/Utils/numberUtils.js\");\n// import AxesRenderer from './Render/AxesRenderer';\n\n\n\n\n // import { calculateRenderedTimestamps } from '../Utils/timestampUtils';\n\n\nconst SLIDING_ANIMATION_DURATION_RATE = 200;\nconst ANIM_DURATION = 300;\nconst RESIZE_THROTTLE_DURATION = 200;\nconst INITIAL_AXE_ALPHA = 0.25;\nconst TIMESTAMP_DEFAULT_WIDTH = 64;\nclass MainWindow {\n  constructor(chart) {\n    this.chart = chart;\n    this.canvas = chart.node.querySelector('.canvas-main-window');\n    this.chartArea = new _ChartArea__WEBPACK_IMPORTED_MODULE_0__[\"default\"](chart, this.canvas, _Settings_mainWindow__WEBPACK_IMPORTED_MODULE_3__[\"padding\"]);\n    this.dataRenderer = new _Render_DataRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.chart, this.chartArea, _Settings_mainWindow__WEBPACK_IMPORTED_MODULE_3__[\"valueLineThickness\"]);\n    this.timeLabelsManager = new _Render_TimeLabelsManager__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.chart, this.chartArea);\n    this.zoomAnimAreaStartScale = null;\n    this.zoomAnimAltAreaStartScale = null;\n    this.popup = chart.node.querySelector('.popup');\n    this.popupFixed = false;\n\n    const getSelTick = (clientX, clientY) => {\n      let tickIndex = this.chartArea.getTickIndexFromClientXOverCanvas(clientX); // const { start, end } = chart.slider.getSelectedTicks();\n\n      if (tickIndex < 0) tickIndex = 0;\n      if (tickIndex > this.data.totalTicks - 1) tickIndex = this.data.totalTicks - 1;\n      return tickIndex;\n    }; // this.canvas.onmouseover = (e) => {\n    //     if (this.data) {\n    //         let tickIndex = this.chartArea.getTickIndexFromClientXOverCanvas(e.clientX);\n    //         console.log(tickIndex);\n    //         // const { start, end } = chart.slider.getSelectedTicks();\n    //         if (tickIndex < 0) tickIndex = 0;\n    //         if (tickIndex > this.data.totalTicks - 1) tickIndex = this.data.totalTicks - 1;\n    //         if (tickIndex !== this.dataRenderer.selectedTick) {\n    //             // this.dataRenderer.updateDataSelectionWithAnimation(tickIndex);\n    //             this.dataRenderer.updateDataSelectionInstantly(tickIndex);\n    //             this.shouldRerender = true;\n    //         }\n    //         this.updatePopup();\n    //     }\n    // };\n\n\n    this.canvas.onmousemove = e => {\n      if (this.data && !this.popupFixed) {\n        const tickIndex = getSelTick(e.pageX, e.pageY);\n\n        if (tickIndex !== this.dataRenderer.selectedTick) {\n          this.dataRenderer.updateDataSelectionInstantly(tickIndex);\n          this.shouldRerender = true;\n        }\n\n        this.updatePopup(e.pageX, e.pageY, tickIndex);\n      }\n    }; // this.canvas.ontouchmove = (e) => {\n    //     e = e.touches[0];\n    //     if (this.data //&& !this.popupFixed\n    //         ) {\n    //         const tickIndex = getSelTick(e.pageX, e.pageY);\n    //         if (tickIndex !== this.dataRenderer.selectedTick) {\n    //             this.dataRenderer.updateDataSelectionInstantly(tickIndex);\n    //             this.shouldRerender = true;\n    //         }\n    //         this.updatePopup(e.pageX, e.pageY, tickIndex);\n    //     }\n    // };\n\n\n    this.canvas.ontouchstart = e => {\n      this.handleClickOrTouch(e.touches[0].pageX, e.touches[0].pageY);\n    };\n\n    this.canvas.onclick = e => {\n      this.handleClickOrTouch(e.pageX, e.pageY);\n    };\n\n    this.handleClickOrTouch = (x, y) => {\n      const tickIndex = getSelTick(x, y);\n      this.fixPopup(tickIndex);\n      this.updatePopup(x, y, tickIndex);\n    };\n\n    this.canvas.onmouseout = () => {\n      // this.dataRenderer.updateDataSelectionWithAnimation(null);\n      if (!this.popupFixed) this.hidePopup();\n    };\n  }\n\n  attachData(data) {\n    this.data = data;\n    this.dataRenderer.attachData(data);\n    this.timeLabelsManager.attachData(data);\n  }\n\n  onAdjustToScreen() {\n    const {\n      canvas\n    } = this;\n    const boundingRect = this.canvas.getBoundingClientRect();\n    const {\n      width,\n      height\n    } = boundingRect; // TODO - which size to use ????\n\n    const pixelRatio = window.devicePixelRatio;\n\n    if (width * pixelRatio !== canvas.width || height * pixelRatio !== canvas.height) {\n      canvas.setAttribute('width', canvas.clientWidth * pixelRatio);\n      canvas.setAttribute('height', canvas.clientHeight * pixelRatio);\n      if (this.data) this.shouldRerender = true;\n    }\n\n    this.timeLabelsManager.onResize();\n  }\n\n  render() {\n    const ctx = this.canvas.getContext('2d');\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.chart.axisManager.resizeChartAreas();\n    const {\n      startTick,\n      endTick\n    } = this.chart.slider.getSelectedTicks();\n    this.dataRenderer.render(startTick, endTick);\n    this.chart.axisManager.renderAxes();\n    this.timeLabelsManager.render();\n    this.shouldRerender = false;\n    const mode = window.app.modeSwitcher.getMode();\n    ctx.fillStyle = mode === 'day' ? '#000000' : '#FFFFFF';\n    ctx.font = `bold ${window.devicePixelRatio >= 2 ? 24 : 16}px Arial`;\n    ctx.fillText(this.chart.name, 5, 18);\n    const selectedDates = !this.chart.isZoomed ? `${Object(_Utils_dateFormaters__WEBPACK_IMPORTED_MODULE_4__[\"getFullDate\"])(this.data.axisDataset.values[startTick])} - ${Object(_Utils_dateFormaters__WEBPACK_IMPORTED_MODULE_4__[\"getFullDate\"])(this.data.axisDataset.values[endTick])}` : `${Object(_Utils_dateFormaters__WEBPACK_IMPORTED_MODULE_4__[\"getFullDateWithDayOfWeek\"])(this.data.axisDataset.values[this.dataRenderer.selectedTick ? this.dataRenderer.selectedTick : endTick])}`;\n    ctx.font = `bold ${window.devicePixelRatio >= 2 ? 21 : 14}px Arial`;\n    ctx.textAlign = 'right';\n    ctx.fillText(selectedDates, this.canvas.width - 5, 18);\n\n    if (this.popupFixed && this.dataRenderer.selectedTickAnim !== null) {\n      this.rerenderPopupValues(Math.round(this.dataRenderer.selectedTick));\n    }\n  } // updatePopup(pageX, pageY) {\n\n\n  updatePopup(x, y, selectedTick) {\n    const allChartWindows = window.app.charts.map(c => c.mainWindow);\n    allChartWindows.forEach(c => {\n      if (c !== this) c.hidePopup();\n    });\n    this.popup.style.display = 'block';\n    const ratio = window.devicePixelRatio;\n    const canvBound = this.canvas.getBoundingClientRect();\n    const popOffsetX = -40;\n    const popOffsetY = -100;\n    this.popup.style.left = `${x + popOffsetX}px`;\n    this.popup.style.top = `${y + popOffsetY}px`;\n    this.popup.style.display = 'block';\n    this.rerenderPopupValues(selectedTick);\n  }\n\n  hidePopup() {\n    this.popup.style.display = 'none';\n    this.popupFixed = false;\n    this.popup.classList.add('noEvents');\n    this.dataRenderer.selectedTick = null;\n    this.dataRenderer.selectedTickAnim = null;\n    this.shouldRerender = true;\n  }\n\n  fixPopup(tickIndex) {\n    this.popupFixed = true;\n    this.popup.classList.remove('noEvents');\n    this.dataRenderer.updateDataSelectionWithAnimation(tickIndex);\n  }\n\n  rerenderPopupValues(selectedTick) {\n    this.popup.querySelector('.title').innerText = !this.chart.isZoomed ? Object(_Utils_dateFormaters__WEBPACK_IMPORTED_MODULE_4__[\"getDateForPopup\"])(this.data.axisDataset.values[selectedTick]) : Object(_Utils_dateFormaters__WEBPACK_IMPORTED_MODULE_4__[\"getHour\"])(this.data.axisDataset.values[selectedTick]);\n    const dataDiv = this.popup.querySelector('.data');\n\n    while (dataDiv.firstChild) {\n      dataDiv.removeChild(dataDiv.firstChild);\n    }\n\n    let sum = 0;\n    this.data.valueDatasets.forEach(d => {\n      if (d.enabled) {\n        sum += d.values[selectedTick];\n        const row = document.createElement('p');\n        row.className = 'column';\n        row.innerHTML = `<div class='label'>${d.name}</div>\n                                <div class='value' style='color:${d.color}'>${Object(_Utils_numberUtils__WEBPACK_IMPORTED_MODULE_5__[\"formatValue\"])(d.values[selectedTick])}</div>`;\n        dataDiv.appendChild(row);\n      }\n    });\n\n    if (this.data.options.stacked && !this.data.options.percentage) {\n      const row = document.createElement('p');\n      row.className = 'column';\n      row.innerHTML = `<div class='label all'>All</div>\n                             <div class='value'>${Object(_Utils_numberUtils__WEBPACK_IMPORTED_MODULE_5__[\"formatValue\"])(sum)}</div>`;\n      dataDiv.appendChild(row);\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/MainWindow.js?");

/***/ }),

/***/ "./src/Charts/Render/DataRenderer.js":
/*!*******************************************!*\
  !*** ./src/Charts/Render/DataRenderer.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataRenderer; });\n/* harmony import */ var _RenderedObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderedObject */ \"./src/Charts/Render/RenderedObject.js\");\n/* harmony import */ var _renderDataUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderDataUtils */ \"./src/Charts/Render/renderDataUtils.js\");\n/* harmony import */ var _chartRenderUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chartRenderUtils */ \"./src/Charts/Render/chartRenderUtils.js\");\n\n\n\nclass DataRenderer extends _RenderedObject__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(chart, chartArea, lineWidth) {\n    super(chartArea);\n    this.chart = chart;\n    this.lineWidth = lineWidth;\n    this.context.lineJoin = 'round';\n    this.selectedTick = null;\n    this.selectedTickAnim = null;\n  }\n\n  attachData(data) {\n    this.data = data;\n  }\n\n  updateDataSelectionWithAnimation(pointedTick) {\n    this.selectedTick = pointedTick;\n    const ANIM_DURATION = 200;\n\n    if (this.selectedTickAnim !== this.selectedTick) {\n      if (this.selectedTick === null) {\n        this.selectedTickAnim = null;\n        delete this.chart.animator.animations['animSelection'];\n      } else if (this.selectedTickAnim === null) {\n        this.selectedTickAnim = this.selectedTick;\n      } else {\n        this.chart.animator.startAnimation('animSelection', newVal => {\n          this.selectedTickAnim = newVal;\n        }, this.selectedTickAnim, this.selectedTick, ANIM_DURATION, true, false, undefined);\n      }\n\n      this.chart.mainWindow.shouldRerender = true;\n    }\n  }\n\n  updateDataSelectionInstantly(pointedTick) {\n    this.selectedTick = pointedTick;\n    this.selectedTickAnim = pointedTick;\n    this.chart.mainWindow.shouldRerender = true;\n  }\n\n  render(startTick = 0, endTick = this.data.totalTicks - 1) {\n    const {\n      canvas,\n      chartArea,\n      context,\n      data,\n      altChartArea\n    } = this;\n\n    if (!data.options.stacked) {\n      data.valueDatasets.forEach(dataset => {\n        if (dataset.presence <= 0) return;\n        if (dataset.type === 'line') Object(_renderDataUtils__WEBPACK_IMPORTED_MODULE_1__[\"renderLine\"])(context, !dataset.useAlternateAxis ? chartArea : altChartArea, dataset, startTick, endTick, this.lineWidth);\n        if (dataset.type === 'bar') Object(_renderDataUtils__WEBPACK_IMPORTED_MODULE_1__[\"renderBars\"])(context, chartArea, dataset, startTick, endTick, this.selectedTickAnim);\n      });\n    } else if (!data.options.percentage) {\n      // TODO - implemented just for bars now.\n      Object(_renderDataUtils__WEBPACK_IMPORTED_MODULE_1__[\"renderStacked\"])(context, chartArea, data.valueDatasets, data.cache, startTick, endTick, this.selectedTickAnim);\n    } else {\n      Object(_renderDataUtils__WEBPACK_IMPORTED_MODULE_1__[\"renderStackedPercentage\"])(context, chartArea, data.valueDatasets, data.cache, startTick, endTick);\n    }\n\n    if (this.selectedTick) {\n      if (data.valueDatasets[0].type === 'line' || data.valueDatasets[0].type === 'area') {\n        Object(_chartRenderUtils__WEBPACK_IMPORTED_MODULE_2__[\"renderSelectionLine\"])(context, chartArea, this.selectedTick);\n      }\n\n      if (data.valueDatasets[0].type === 'line') Object(_chartRenderUtils__WEBPACK_IMPORTED_MODULE_2__[\"renderLineChartSelection\"])(context, chartArea, altChartArea, data.valueDatasets, this.selectedTickAnim);\n    }\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/Render/DataRenderer.js?");

/***/ }),

/***/ "./src/Charts/Render/RenderedObject.js":
/*!*********************************************!*\
  !*** ./src/Charts/Render/RenderedObject.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return RenderedObject; });\nclass RenderedObject {\n  constructor(chartArea) {\n    this.chartArea = chartArea;\n    this.canvas = chartArea.canvas;\n    this.context = chartArea.canvas.getContext('2d');\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/Render/RenderedObject.js?");

/***/ }),

/***/ "./src/Charts/Render/TimeLabelsManager.js":
/*!************************************************!*\
  !*** ./src/Charts/Render/TimeLabelsManager.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TimeLabelsManager; });\n/* harmony import */ var _RenderedObject__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./RenderedObject */ \"./src/Charts/Render/RenderedObject.js\");\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Settings */ \"./src/Settings/index.js\");\n/* harmony import */ var _Utils_dateFormaters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Utils/dateFormaters */ \"./src/Utils/dateFormaters.js\");\n/* harmony import */ var _Utils_textUtils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../Utils/textUtils */ \"./src/Utils/textUtils.js\");\n\n\n\n\nconst TEXT_X_OFFSET = -16 * 0;\nconst LABEL_WIDTH = 90;\nconst ANIM_DURATION = 200;\nclass TimeLabelsManager extends _RenderedObject__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(chart, chartArea) {\n    super(chartArea);\n    this.chart = chart;\n  }\n\n  attachData(data) {\n    this.data = data;\n    this.labels = {};\n    this.scale = this.calculateNewScale();\n    const initialLabels = this.calculateNewLabels(this.scale, true);\n    this.updateLabels(initialLabels);\n  }\n\n  calculateNewScale() {\n    const p = this.chartArea.padding;\n    const totTicks = this.data.totalTicks;\n    const canvFullWidth = (this.canvas.width - p.right - p.left) / (this.chart.slider.selection.to - this.chart.slider.selection.from);\n    const totalTicksScale = Math.floor(Math.log2(totTicks));\n    const labelsOnScreen = Math.floor(Math.log2(canvFullWidth / LABEL_WIDTH));\n    return 2 ** totalTicksScale / 2 ** labelsOnScreen;\n  }\n\n  calculateNewLabels(scale, present = false) {\n    const newLabels = {};\n\n    for (let i = this.data.totalTicks - 1; i >= 0; i -= scale) {\n      const time = this.data.axisDataset.values[i];\n      newLabels[time] = {\n        tick: i,\n        text: !this.chart.isZoomed ? Object(_Utils_dateFormaters__WEBPACK_IMPORTED_MODULE_2__[\"getShortDate\"])(time) : Object(_Utils_dateFormaters__WEBPACK_IMPORTED_MODULE_2__[\"getHour\"])(time),\n        presence: present ? 1 : 0\n      };\n    }\n\n    return newLabels;\n  }\n\n  updateLabels(newLabels) {\n    // Remove old.\n    Object.entries(this.labels).forEach(([time, label]) => {\n      if (newLabels[time] === undefined) {\n        this.chart.animator.startAnimation(`timelabel_${time}`, newValue => {\n          this.labels[time].presence = newValue;\n        }, label.presence, 0, ANIM_DURATION, true, false, () => {\n          delete this.labels[time];\n        });\n      }\n    }); // Add new and update existing.\n\n    Object.entries(newLabels).forEach(([time, label]) => {\n      if (this.labels[time] === undefined) {\n        this.labels[time] = label;\n      }\n\n      if (this.labels[time].presence < 1) {\n        this.chart.animator.startAnimation(`timelabel_${time}`, newValue => {\n          this.labels[time].presence = newValue;\n        }, label.presence, 1, ANIM_DURATION, true, false);\n      }\n    });\n  }\n\n  onResize() {\n    if (this.scale !== undefined) {\n      const newScale = this.calculateNewScale();\n\n      if (this.scale !== newScale) {\n        this.scale = newScale;\n        const newLabels = this.calculateNewLabels(newScale);\n        this.updateLabels(newLabels);\n      }\n    }\n  }\n\n  render() {\n    const {\n      chartArea,\n      context\n    } = this;\n    context.fillStyle = _Settings__WEBPACK_IMPORTED_MODULE_1__[\"chartTextColor\"];\n    context.font = _Settings__WEBPACK_IMPORTED_MODULE_1__[\"chartTextFont\"];\n    context.textAlign = 'right';\n    const {\n      startTick,\n      endTick\n    } = this.chart.slider.getSelectedTicks();\n    Object.values(this.labels).forEach(label => {\n      if (startTick <= label.tick && label.tick <= endTick) {\n        const position = chartArea.getCanvasPositionForTimestamp(label.tick);\n        context.globalAlpha = label.presence;\n        context.fillText(label.text, position.x + TEXT_X_OFFSET, position.y);\n      }\n    });\n    context.globalAlpha = 1;\n    context.textAlign = 'left';\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/Render/TimeLabelsManager.js?");

/***/ }),

/***/ "./src/Charts/Render/chartRenderUtils.js":
/*!***********************************************!*\
  !*** ./src/Charts/Render/chartRenderUtils.js ***!
  \***********************************************/
/*! exports provided: renderSelectionLine, renderAxes, renderLineChartSelection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderSelectionLine\", function() { return renderSelectionLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderAxes\", function() { return renderAxes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderLineChartSelection\", function() { return renderLineChartSelection; });\n/* harmony import */ var _Settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Settings */ \"./src/Settings/index.js\");\n/* harmony import */ var _Utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Utils/numberUtils */ \"./src/Utils/numberUtils.js\");\n\n\n\n\nconst renderAxisLine = (context, chartArea, value) => {\n  const theme = window.app.modeSwitcher.getMode();\n  const themeSet = _Settings__WEBPACK_IMPORTED_MODULE_0__[\"themeSpecific\"][theme];\n  context.strokeStyle = themeSet.gridLinesColor;\n  context.globalAlpha = themeSet.gridLinesAlpha;\n  context.lineWidth = 1 * window.devicePixelRatio;\n  const position = chartArea.getCanvasPositionForHorizontalAxis(value);\n  context.beginPath();\n  context.moveTo(position.xStart, position.y);\n  context.lineTo(position.xEnd, position.y);\n  context.stroke();\n};\n\nconst renderSelectionLine = (context, chartArea, tick) => {\n  const theme = window.app.modeSwitcher.getMode();\n  const themeSet = _Settings__WEBPACK_IMPORTED_MODULE_0__[\"themeSpecific\"][theme];\n  context.strokeStyle = themeSet.gridLinesColor;\n  context.globalAlpha = themeSet.gridLinesAlpha;\n  context.lineWidth = 1 * window.devicePixelRatio;\n  const position = chartArea.getCanvasPositionForVerticalAxis(tick);\n  context.beginPath();\n  context.moveTo(position.x, position.yStart);\n  context.lineTo(position.x, position.yEnd);\n  context.stroke();\n};\nconst renderAxes = (axes, canvas, chartArea, percentage, axesTextColor, alternate = false, datasetPresence) => {\n  const context = canvas.getContext('2d');\n  context.strokeStyle = _Settings__WEBPACK_IMPORTED_MODULE_0__[\"chartAxisColor\"]; // context.lineWidth = chartAxisLineThickness;\n\n  context.fillStyle = axesTextColor || '#8E8E93';\n  context.font = axesTextColor ? 'bold 14px Arial' : _Settings__WEBPACK_IMPORTED_MODULE_0__[\"chartTextFont\"];\n  context.textAlign = alternate ? 'right' : 'left';\n  Object.entries(axes).forEach(([value, presence]) => {\n    // context.globalAlpha = 0.25;\n    if (!alternate) renderAxisLine(context, chartArea, value);\n    const point = chartArea.getCanvasPositionForValueLabel(value, alternate); // if (presence > 1) presence = 1;\n    // if (datasetPresence > 1) datasetPresence = 1;\n    // if (datasetPresence < 0) datasetPresence = 0;\n\n    context.globalAlpha = presence * (datasetPresence !== undefined ? datasetPresence : 1);\n    const text = Object(_Utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__[\"formatValue\"])(value, percentage);\n    context.fillText(text, point.x, point.y);\n  });\n  context.globalAlpha = 1;\n  context.textAlign = 'left';\n};\nconst renderLineChartSelection = (context, chartArea, altChartArea, valueDatasets, tick) => {\n  const valueDatasetsToRender = valueDatasets.filter(d => d.enabled);\n  valueDatasetsToRender.forEach(dataset => {\n    const area = !dataset.useAlternateAxis ? chartArea : altChartArea;\n    const val = tick % 1 === 0 ? dataset.values[tick] : (dataset.values[Math.ceil(tick)] + dataset.values[Math.floor(tick)]) / 2;\n    const point = area.getCanvasPositionForPoint(val, tick);\n    context.globalAlpha = 1;\n    context.strokeStyle = dataset.color;\n    context.lineWidth = 3 * window.devicePixelRatio;\n    context.beginPath();\n    context.arc(point.x, point.y, 3 * window.devicePixelRatio, 0, 2 * Math.PI);\n    context.stroke();\n    context.fillStyle = window.app.modeSwitcher.getMode() === 'day' ? '#FFFFFF' : '#242F3E';\n    context.fill();\n    context.fillStyle = '#000000';\n  });\n};\n\n//# sourceURL=webpack:///./src/Charts/Render/chartRenderUtils.js?");

/***/ }),

/***/ "./src/Charts/Render/renderDataUtils.js":
/*!**********************************************!*\
  !*** ./src/Charts/Render/renderDataUtils.js ***!
  \**********************************************/
/*! exports provided: renderLine, renderBars, renderStacked, renderStackedPercentage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderLine\", function() { return renderLine; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderBars\", function() { return renderBars; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderStacked\", function() { return renderStacked; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderStackedPercentage\", function() { return renderStackedPercentage; });\nconst renderLine = (context, chartArea, dataset, startTick, endTick, lineWidth) => {\n  const {\n    color,\n    presence,\n    values\n  } = dataset;\n  context.strokeStyle = color;\n  context.globalAlpha = presence;\n  context.lineWidth = lineWidth * window.devicePixelRatio;\n  context.beginPath();\n  const startPoint = chartArea.getCanvasPositionForPoint(values[startTick], startTick);\n  context.moveTo(startPoint.x, startPoint.y);\n\n  for (let i = startTick + 1; i <= endTick; i++) {\n    const point = chartArea.getCanvasPositionForPoint(values[i], i);\n    context.lineTo(point.x, point.y);\n  }\n\n  context.stroke();\n  context.globalAlpha = 1;\n};\nconst renderBars = (context, chartArea, dataset, startTick, endTick, selectedTickAnim) => {\n  let {\n    x2: prevBarEndX\n  } = chartArea.getCanvasPositionForBar(startTick - 1, 0, 0);\n  const barSelected = !(selectedTickAnim === undefined || selectedTickAnim === null);\n  const selected = Math.round(selectedTickAnim);\n\n  for (let i = startTick; i <= endTick; i++) {\n    context.fillStyle = dataset.color;\n    context.globalAlpha = !barSelected ? dataset.presence : dataset.presence * (selected === i ? 1 : 0.5);\n    const position = chartArea.getCanvasPositionForBar(i, dataset.values[i]);\n    context.fillRect(position.x1, position.y, position.x2 - position.x1, position.height); // Adjust x coordinate.\n    // position.x1 = prevBarEndX;\n\n    prevBarEndX = position.x2;\n  }\n\n  context.globalAlpha = 1;\n}; // TODO - implemented just for bars now.\n\nconst renderStacked = (context, chartArea, valueDatasets, cache, startTick, endTick, selectedTickAnim) => {\n  const barSelected = !(selectedTickAnim === undefined || selectedTickAnim === null);\n  const selected = Math.round(selectedTickAnim);\n  let {\n    x2: prevBarEndX\n  } = chartArea.getCanvasPositionForBar(startTick - 1, 0, 0);\n\n  for (let i = startTick; i <= endTick; i++) {\n    const position = chartArea.getCanvasPositionForStackedValues_BARS(i, cache[i]); // TODO - Adjust x coordinate.\n    // position.x1 = prevBarEndX;\n\n    prevBarEndX = position.x2; // eslint-disable-next-line no-loop-func\n\n    valueDatasets.forEach((dataset, ind) => {\n      if (dataset.presence <= 0 || position.bars[ind].height === 0) return;\n      context.fillStyle = dataset.color;\n      context.globalAlpha = !barSelected ? dataset.presence : dataset.presence * (selected === i ? 1 : 0.5);\n      context.fillRect(position.x1, position.bars[ind].y, position.x2 - position.x1, position.bars[ind].height);\n    });\n  }\n\n  context.globalAlpha = 1;\n}; // first point of path should already be initiated!\n\nconst buildPathForStackedPoints = (context, stackedPoints, dataInd, reverted) => {\n  if (!reverted) {\n    for (let i = 1; i < stackedPoints.length; i++) {\n      context.lineTo(stackedPoints[i].x, stackedPoints[i].ys[dataInd]);\n    }\n  } else {\n    for (let i = stackedPoints.length - 1; i >= 0; i--) {\n      context.lineTo(stackedPoints[i].x, stackedPoints[i].ys[dataInd]);\n    }\n  }\n};\n\nconst renderArea = (context, stackedPoints, dataset, dataInd, chartBottomY) => {\n  context.fillStyle = dataset.color;\n  context.globalAlpha = dataset.presence;\n  const endTick = stackedPoints.length - 1;\n  context.beginPath();\n  context.moveTo(stackedPoints[0].x, stackedPoints[0].ys[dataInd]);\n  buildPathForStackedPoints(context, stackedPoints, dataInd, false);\n\n  if (dataInd !== 0) {\n    context.lineTo(stackedPoints[endTick].x, stackedPoints[endTick].ys[dataInd - 1]);\n    buildPathForStackedPoints(context, stackedPoints, dataInd - 1, true);\n    context.lineTo(stackedPoints[0].x, stackedPoints[0].ys[dataInd]);\n  } else {\n    context.lineTo(stackedPoints[endTick].x, chartBottomY);\n    context.lineTo(stackedPoints[0].x, chartBottomY);\n    context.lineTo(stackedPoints[0].x, stackedPoints[0].ys[dataInd]);\n  }\n\n  context.closePath();\n  context.fill();\n};\n\nconst renderStackedPercentage = (context, chartArea, valueDatasets, cache, startTick, endTick) => {\n  const stackedPoints = [];\n  const step = endTick - startTick;\n\n  for (let i = startTick; i <= endTick; i += 1) {\n    stackedPoints.push(chartArea.getCanvasPositionForStackedPercentageValues(i, cache[i]));\n  }\n\n  const chartBottomY = chartArea.getChartBottomY();\n  valueDatasets.forEach((dataset, dataInd) => {\n    renderArea(context, stackedPoints, dataset, dataInd, chartBottomY);\n  });\n};\n\n//# sourceURL=webpack:///./src/Charts/Render/renderDataUtils.js?");

/***/ }),

/***/ "./src/Charts/Render/uiRenderUtils.js":
/*!********************************************!*\
  !*** ./src/Charts/Render/uiRenderUtils.js ***!
  \********************************************/
/*! exports provided: renderSliderUI */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"renderSliderUI\", function() { return renderSliderUI; });\n/* harmony import */ var _Settings_slider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Settings/slider */ \"./src/Settings/slider.js\");\n/* harmony import */ var _Styles_slider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Styles/slider */ \"./src/Styles/slider.js\");\n\n // eslint-disable-next-line import/prefer-default-export\n\nconst renderSliderUI = (canvas, selection, mode) => {\n  const context = canvas.getContext('2d');\n  const pixelRatio = window.devicePixelRatio;\n  const vertBordWidth = _Styles_slider__WEBPACK_IMPORTED_MODULE_1__[\"style\"].uiVertBorderWidth * pixelRatio;\n  const horBordWidth = _Styles_slider__WEBPACK_IMPORTED_MODULE_1__[\"style\"].uiHorBorderWidth * pixelRatio;\n  const startX = canvas.width * selection.from;\n  const endX = canvas.width * selection.to;\n  const theme = _Styles_slider__WEBPACK_IMPORTED_MODULE_1__[\"themeDependent\"][mode];\n  context.fillStyle = theme.scrollBackgroundColor;\n  context.globalAlpha = theme.scrollBackgroundOpacity; // Areas\n\n  context.fillRect(0, 0, startX + vertBordWidth, canvas.height);\n  context.fillRect(endX - vertBordWidth, 0, canvas.width - endX + vertBordWidth, canvas.height); // Frame\n\n  context.fillStyle = theme.scrollSelectorColor;\n  context.globalAlpha = 1;\n  context.fillRect(startX + vertBordWidth, 0, endX - startX - vertBordWidth * 2, horBordWidth);\n  context.fillRect(startX + vertBordWidth, canvas.height - horBordWidth, endX - startX - vertBordWidth * 2, horBordWidth);\n  const radius = _Styles_slider__WEBPACK_IMPORTED_MODULE_1__[\"style\"].borderRadius * pixelRatio;\n  context.beginPath();\n  context.moveTo(startX + vertBordWidth, 0);\n  context.quadraticCurveTo(startX, 0, startX, radius);\n  context.lineTo(startX, canvas.height - radius);\n  context.quadraticCurveTo(startX, canvas.height, startX + vertBordWidth, canvas.height);\n  context.fill();\n  context.beginPath();\n  context.moveTo(endX - vertBordWidth, 0);\n  context.quadraticCurveTo(endX, 0, endX, radius);\n  context.lineTo(endX, canvas.height - radius);\n  context.quadraticCurveTo(endX, canvas.height, endX - vertBordWidth, canvas.height);\n  context.fill();\n  context.strokeStyle = '#ffffff';\n  context.lineCap = 'round';\n  context.lineWidth = 3 * pixelRatio;\n  const height = 13 * pixelRatio;\n  const y = canvas.height / 2 - height / 2;\n  let x = startX + vertBordWidth / 2;\n  context.beginPath();\n  context.moveTo(x, y);\n  context.lineTo(x, y + height);\n  context.stroke();\n  x = endX - vertBordWidth / 2;\n  context.beginPath();\n  context.moveTo(x, y);\n  context.lineTo(x, y + height);\n  context.stroke();\n  context.globalAlpha = 1;\n};\n\n//# sourceURL=webpack:///./src/Charts/Render/uiRenderUtils.js?");

/***/ }),

/***/ "./src/Charts/Slider.js":
/*!******************************!*\
  !*** ./src/Charts/Slider.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Slider; });\n/* harmony import */ var _ChartArea__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ChartArea */ \"./src/Charts/ChartArea.js\");\n/* harmony import */ var _Render_DataRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Render/DataRenderer */ \"./src/Charts/Render/DataRenderer.js\");\n/* harmony import */ var _Render_uiRenderUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Render/uiRenderUtils */ \"./src/Charts/Render/uiRenderUtils.js\");\n/* harmony import */ var _SliderDraggableArea__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SliderDraggableArea */ \"./src/Charts/SliderDraggableArea.js\");\n/* harmony import */ var _Settings_slider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Settings/slider */ \"./src/Settings/slider.js\");\n/* harmony import */ var _Styles_slider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Styles/slider */ \"./src/Styles/slider.js\");\n\n\n\n\n\n\nconst ANIM_DURATION = 200;\nclass Slider {\n  constructor(chart) {\n    this.chart = chart;\n    this.canvas = chart.node.querySelector('.canvas-slider');\n    this.chartArea = new _ChartArea__WEBPACK_IMPORTED_MODULE_0__[\"default\"](chart, this.canvas, _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].padding);\n    this.dataRenderer = new _Render_DataRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.chart, this.chartArea, _Styles_slider__WEBPACK_IMPORTED_MODULE_5__[\"style\"].lineWidth);\n    this.selection = {\n      from: 1 - _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].selectionInitialRange,\n      to: 1\n    };\n    const {\n      canvas,\n      chartArea,\n      selection\n    } = this;\n    this.startDraggable = new _SliderDraggableArea__WEBPACK_IMPORTED_MODULE_3__[\"default\"](canvas, chartArea, 'cursor-resize');\n    this.centralDraggable = new _SliderDraggableArea__WEBPACK_IMPORTED_MODULE_3__[\"default\"](canvas, chartArea, 'cursor-move');\n    this.endDraggable = new _SliderDraggableArea__WEBPACK_IMPORTED_MODULE_3__[\"default\"](canvas, chartArea, 'cursor-resize');\n    this.updateDraggableAreaBounds();\n\n    this.startDraggable.onDrag = newValue => {\n      const maxValue = selection.to - _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].selectionMinRange;\n      if (newValue > maxValue) newValue = maxValue;\n      this.selection.from = newValue;\n      this.updateDraggableAreaBounds();\n      this.shouldRerender = true;\n      this.chart.onSliderChanged();\n    };\n\n    this.centralDraggable.onDrag = newValue => {\n      const halfRange = (this.selection.to - this.selection.from) / 2;\n      const minValue = 0 + halfRange;\n      const maxValue = 1 - halfRange;\n      if (newValue < minValue) newValue = minValue;\n      if (newValue > maxValue) newValue = maxValue;\n      this.selection.from = newValue - halfRange;\n      this.selection.to = newValue + halfRange;\n      this.updateDraggableAreaBounds();\n      this.shouldRerender = true;\n      this.chart.onSliderChanged();\n    };\n\n    this.endDraggable.onDrag = newValue => {\n      const minValue = this.selection.from + _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].selectionMinRange;\n      if (newValue < minValue) newValue = minValue;\n      this.selection.to = newValue;\n      this.updateDraggableAreaBounds();\n      this.shouldRerender = true;\n      this.chart.onSliderChanged();\n    };\n\n    this.canvas.ontouchstart = e => {\n      const allChartWindows = window.app.charts.map(c => c.mainWindow);\n      allChartWindows.forEach(c => {\n        c.hidePopup();\n      });\n    };\n  }\n\n  enable() {\n    console.log('slider enabled');\n  }\n\n  disable() {\n    console.log('slider disabled');\n  }\n\n  updateDraggableAreaBounds() {\n    const {\n      canvas,\n      selection\n    } = this;\n    const pixelRatio = window.devicePixelRatio;\n    const fromX = Math.floor(canvas.width * selection.from);\n    const toX = Math.ceil(canvas.width * selection.to);\n    const dragStartX = fromX - _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].draggableOffset * pixelRatio;\n    const dragEndX = toX + _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].draggableOffset * pixelRatio - _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].draggableWidth * pixelRatio;\n    this.startDraggable.setBounds(dragStartX, 0, _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].draggableWidth * pixelRatio, canvas.height);\n    this.centralDraggable.setBounds(dragStartX + _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].draggableWidth * pixelRatio, 0, dragEndX - dragStartX - _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].draggableWidth * pixelRatio, canvas.height);\n    this.endDraggable.setBounds(dragEndX, 0, _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].draggableWidth * pixelRatio, canvas.height);\n  }\n\n  attachData(data) {\n    this.data = data;\n    this.dataRenderer.attachData(data);\n    this.minMax = data.getMinMaxValues();\n\n    if (data.options.doubleAxis) {\n      this.altChartArea = new _ChartArea__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.chart, this.canvas, _Settings_slider__WEBPACK_IMPORTED_MODULE_4__[\"settings\"].padding);\n      this.dataRenderer.altChartArea = this.altChartArea;\n    }\n  }\n\n  getSelectedTicks() {\n    const startTick = Math.floor((this.data.totalTicks - 1) * this.selection.from);\n    const endTick = Math.ceil((this.data.totalTicks - 1) * this.selection.to);\n    return {\n      startTick,\n      endTick\n    };\n  }\n\n  onAdjustToScreen() {\n    const boundingRect = this.chartArea.canvas.getBoundingClientRect();\n    const {\n      width,\n      height\n    } = boundingRect;\n    const {\n      canvas\n    } = this;\n    const pixelRatio = window.devicePixelRatio;\n\n    if (width * pixelRatio !== canvas.width || height * pixelRatio !== canvas.height) {\n      // alert(`${this.chart.node.id}, SLIDER: c.w/h = ${canvas.width} ; ${canvas.height}.   bcr. w/h = ${width} ; ${height} `);\n      this.canvas.setAttribute('width', width * pixelRatio);\n      this.canvas.setAttribute('height', height * pixelRatio);\n      this.updateDraggableAreaBounds();\n\n      if (this.data) {\n        this.render();\n      }\n    }\n  }\n\n  render() {\n    const {\n      chartArea,\n      minMax\n    } = this;\n    this.canvas.getContext('2d').clearRect(0, 0, this.canvas.width, this.canvas.height);\n    chartArea.updateSizing(minMax, {\n      from: 0,\n      to: 1\n    });\n\n    if (this.altChartArea) {\n      const altMinMax = this.data.getMinMaxValuesForAlternateAxis(0, this.data.totalTicks - 1);\n      this.altChartArea.updateSizing(altMinMax, {\n        from: 0,\n        to: 1\n      });\n    }\n\n    if (this.dataRenderer) this.dataRenderer.render();\n    Object(_Render_uiRenderUtils__WEBPACK_IMPORTED_MODULE_2__[\"renderSliderUI\"])(this.canvas, this.selection, window.app.modeSwitcher.getMode());\n    this.shouldRerender = false;\n\n    const renderDragArea = (color, draggable) => {\n      this.canvas.getContext('2d').fillStyle = color;\n      this.canvas.getContext('2d').fillRect(draggable.x, draggable.y, draggable.width, draggable.height);\n    };\n\n    if (window.DEBUG_MODE) {\n      renderDragArea('rgba(255,0,0,0.25)', this.startDraggable);\n      renderDragArea('rgba(0,255,0,0.25)', this.centralDraggable);\n      renderDragArea('rgba(0,0,255,0.25)', this.endDraggable);\n    }\n  }\n\n  animateUpdateMinMax() {\n    if (this.data.isAllDataDisabled()) return;\n    const newMinMax = this.data.getMinMaxValues();\n    this.chart.animator.startAnimation('slider_minValue', newValue => {\n      this.minMax.min = newValue;\n    }, this.minMax.min, newMinMax.min, ANIM_DURATION, false, true);\n    this.chart.animator.startAnimation('slider_maxValue', newValue => {\n      this.minMax.max = newValue;\n    }, this.minMax.max, newMinMax.max, ANIM_DURATION, false, true);\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/Slider.js?");

/***/ }),

/***/ "./src/Charts/SliderDraggableArea.js":
/*!*******************************************!*\
  !*** ./src/Charts/SliderDraggableArea.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SliderDraggableArea; });\nclass SliderDraggableArea {\n  constructor(canvas, chartArea, cursorClassName) {\n    this.canvas = canvas;\n    this.chartArea = chartArea;\n    this.active = false; // this.divForCursor = document.createElement('div');\n    // this.divForCursor.classList.add('canvas-draggable-cursor');\n    // this.divForCursor.classList.add(cursorClassName);\n    // canvas.parentElement.insertBefore(this.divForCursor, canvas);\n\n    canvas.addEventListener('mousedown', e => {\n      this.handleClick(e.clientX, e.clientY);\n    });\n    canvas.addEventListener('touchstart', e => {\n      this.handleClick(e.touches[0].clientX, e.touches[0].clientY);\n    });\n    document.addEventListener('mouseup', () => {\n      this.active = false;\n    });\n    document.addEventListener('touchend', () => {\n      this.active = false;\n    });\n    document.addEventListener('touchcancel', () => {\n      this.active = false;\n    });\n    document.addEventListener('mousemove', e => {\n      if (this.active) this.handleMove(e.clientX, e.clientY);\n    });\n    document.addEventListener('touchmove', e => {\n      if (this.active) this.handleMove(e.touches[0].clientX, e.touches[0].clientY);\n    });\n  }\n\n  setBounds(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height; // this.divForCursor.setAttribute('style', `left:${x + this.canvas.offsetLeft}px;width:${width}px;height:${height}px;`);\n    // this.divForCursor.setAttribute('height', height);\n  }\n\n  getCenterPosition() {\n    return {\n      x: this.x + this.width / 2,\n      y: this.y + this.height / 2\n    };\n  }\n\n  testPointEntry(pointX, pointY) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    return x <= pointX && pointX <= x + width && y <= pointY && pointY <= y + height;\n  }\n\n  handleClick(clientX, clientY) {\n    const positionOnCanvas = this.chartArea.getCanvasPositionFromClientOverCanvas(clientX, clientY);\n    const clicked = this.testPointEntry(positionOnCanvas.x, positionOnCanvas.y);\n\n    if (clicked) {\n      this.active = true;\n      this.offset = {\n        x: positionOnCanvas.x - this.x - this.width / 2,\n        y: positionOnCanvas.y - this.y - this.height / 2\n      };\n    }\n  }\n\n  handleMove(clientX, clientY) {\n    const positionOnCanvas = this.chartArea.getCanvasPositionFromClientOverCanvas(clientX, clientY);\n    let relativeX = (positionOnCanvas.x - this.offset.x) / this.canvas.width;\n    if (relativeX < 0) relativeX = 0;\n    if (relativeX > 1) relativeX = 1;\n    this.onDrag(relativeX);\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Charts/SliderDraggableArea.js?");

/***/ }),

/***/ "./src/Data/Data.js":
/*!**************************!*\
  !*** ./src/Data/Data.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Data; });\n/* harmony import */ var _Dataset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dataset */ \"./src/Data/Dataset.js\");\n/* harmony import */ var _Utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils/numberUtils */ \"./src/Utils/numberUtils.js\");\n\n // TODO - this is for performance tests.\n\nconst multiplyColumns = (columns, rate) => {\n  let bigColumn = [];\n  const jsonColumns = JSON.stringify(columns);\n\n  for (let i = 0; i < rate; i++) bigColumn = bigColumn.concat(JSON.parse(jsonColumns));\n\n  return bigColumn;\n};\n\nconst mapRawDataToDatasets = rawData => {\n  const {\n    colors,\n    columns,\n    names,\n    types\n  } = rawData;\n  const datasets = columns.map(column => {\n    const id = column[0];\n    return new _Dataset__WEBPACK_IMPORTED_MODULE_0__[\"default\"](id, names[id], types[id], colors[id], column.slice(1));\n  });\n  return datasets;\n};\n\nclass Data {\n  constructor(rawData) {\n    const datasets = mapRawDataToDatasets(rawData);\n    this.axisDataset = datasets.find(d => d.type === 'x');\n    this.valueDatasets = datasets.filter(d => d.type !== 'x');\n    this.totalTicks = this.axisDataset.values.length;\n    this.options = {};\n\n    if (rawData.y_scaled) {\n      this.options.doubleAxis = rawData.y_scaled; // Stick second line to alternate axis for this type of data (by default)\n\n      this.valueDatasets[1].useAlternateAxis = true;\n    }\n\n    if (rawData.stacked) this.options.stacked = rawData.stacked;\n    if (rawData.percentage) this.options.percentage = rawData.percentage;\n  }\n\n  isAllDataDisabled() {\n    return this.valueDatasets.filter(d => d.enabled).length === 0;\n  } // Cache all min/max values and stacked/percentages values for all the data.\n\n\n  refreshCache() {\n    const {\n      valueDatasets,\n      options,\n      totalTicks\n    } = this;\n    delete this.cache;\n    this.cache = [];\n    if (options.doubleAxis) return; // cache for this option is currently not supported.\n\n    if (!options.stacked) {\n      // Absolute not stacked values\n      const enabledDatasets = valueDatasets.filter(d => d.enabled);\n      if (enabledDatasets.length <= 1) return; // do not cache if don't need\n\n      for (let i = 0; i < totalTicks; i++) {\n        let min = Infinity;\n        let max = -Infinity;\n        enabledDatasets.forEach(dataset => {\n          if (dataset.values[i] < min) min = dataset.values[i];\n          if (dataset.values[i] > max) max = dataset.values[i];\n        });\n        this.cache.push({\n          min,\n          max\n        });\n      }\n    } else if (!options.percentage) {\n      // Absolute stacked values\n      for (let i = 0; i < totalTicks; i++) {\n        let sum = 0; // sum of enabled datasets (for chart scaling)\n\n        let animSum = 0; // used for animation\n\n        const values = {};\n        valueDatasets.forEach((dataset, ind) => {\n          if (dataset.enabled) sum += dataset.values[i];\n          animSum += dataset.values[i] * dataset.presence;\n          values[ind] = animSum;\n        });\n        this.cache.push({\n          values,\n          sum\n        });\n      }\n    } else {\n      // Percentage stacked values.\n      // TODO - delete snippet ?      SHOULD TEST THIS METHOD!!!\n      // const presentDatasets = valueDatasets.filter(d => d.presence > 0);\n      // if (presentDatasets.length <= 1) return; // do not cache if don't need\n      // TODO - delete snippet ?\n      for (let i = 0; i < totalTicks; i++) {\n        let sum = 0;\n        const values = {};\n        valueDatasets.forEach((dataset, ind) => {\n          const value = dataset.values[i] * dataset.presence;\n          sum += value;\n          values[ind] = sum;\n        });\n        valueDatasets.forEach((dataset, ind) => {\n          values[ind] = values[ind] / sum * 100;\n        });\n        this.cache.push({\n          values\n        });\n      }\n    }\n\n    this.minMax = this.getMinMaxValues();\n  }\n\n  getMinMaxValues(startTick = 0, endTick = this.totalTicks - 1) {\n    const {\n      valueDatasets,\n      options,\n      cache\n    } = this;\n    if (options.stacked && options.percentage) return {\n      min: 0,\n      max: 100\n    };\n    const isLineType = valueDatasets.every(d => d.type === 'line');\n\n    if (options.doubleAxis) {\n      // calculate min max just right here.\n      const mainDataset = valueDatasets.find(d => !d.useAlternateAxis);\n\n      if (!mainDataset.enabled) {\n        return this.minMax; // return cached result for main axis.\n      }\n\n      let min = mainDataset.values[startTick];\n      let max = mainDataset.values[startTick];\n\n      for (let i = startTick + 1; i <= endTick; i++) {\n        if (min > mainDataset.values[i]) min = mainDataset.values[i];\n        if (max < mainDataset.values[i]) max = mainDataset.values[i];\n      }\n\n      this.minMax = {\n        min,\n        max\n      };\n      return {\n        min: !isLineType ? 0 : min,\n        max\n      };\n    }\n\n    if (!options.stacked) {\n      const enabledDatasets = valueDatasets.filter(d => d.enabled);\n\n      if (enabledDatasets.length > 1) {\n        let {\n          min,\n          max\n        } = cache[startTick];\n\n        for (let i = startTick + 1; i < endTick; i++) {\n          if (min > cache[i].min) min = cache[i].min;\n          if (max < cache[i].max) max = cache[i].max;\n        }\n\n        return {\n          min: !isLineType ? 0 : min,\n          max\n        };\n      }\n\n      if (enabledDatasets.length === 1) {\n        let min = enabledDatasets[0].values[startTick];\n        let max = enabledDatasets[0].values[startTick];\n\n        for (let i = startTick + 1; i < endTick; i++) {\n          if (min > enabledDatasets[0].values[i]) min = enabledDatasets[0].values[i];\n          if (max < enabledDatasets[0].values[i]) max = enabledDatasets[0].values[i];\n        }\n\n        const minMax = {\n          min: !isLineType ? 0 : min,\n          max\n        };\n        this.minMax = minMax; // cache this value for case when last data is disabled (TODO)\n\n        return minMax;\n      }\n\n      return this.minMax;\n    } // Stacked absolute\n\n\n    const enabledDatasets = valueDatasets.filter(d => d.enabled);\n\n    if (enabledDatasets.length > 1) {\n      let max = cache[startTick].sum;\n\n      for (let i = startTick + 1; i < endTick; i++) {\n        if (max < cache[i].sum) max = cache[i].sum;\n      }\n\n      return {\n        min: 0,\n        max\n      };\n    }\n\n    if (enabledDatasets.length === 1) {\n      let max = enabledDatasets[0].values[startTick];\n\n      for (let i = startTick + 1; i < endTick; i++) {\n        if (max < enabledDatasets[0].values[i]) max = cache[i].sum;\n      }\n\n      return {\n        min: 0,\n        max\n      };\n    }\n\n    return this.minMax;\n  }\n\n  getMinMaxValuesForAlternateAxis(startTick = 0, endTick = this.totalTicks - 1) {\n    if (!this.options.doubleAxis) return undefined;\n    const isLineType = this.valueDatasets.every(d => d.type === 'line');\n    const altDataset = this.valueDatasets.find(d => d.useAlternateAxis);\n\n    if (!altDataset.enabled) {\n      return this.altMinMax; // return cached result.\n    }\n\n    let min = altDataset.values[startTick];\n    let max = altDataset.values[startTick];\n\n    for (let i = startTick + 1; i <= endTick; i++) {\n      if (min > altDataset.values[i]) min = altDataset.values[i];\n      if (max < altDataset.values[i]) max = altDataset.values[i];\n    }\n\n    this.altMinMax = {\n      min,\n      max\n    };\n    return {\n      min: !isLineType ? 0 : min,\n      max\n    };\n  } // TODO - refactor / move ???\n\n\n  getStackedPercentageValues(tick, datasetsToInclude = this.valueDatasets, digits = 2) {\n    const result = {};\n    let sum = 0;\n    let animatedSum = 0;\n    datasetsToInclude.forEach((dataset, index) => {\n      const value = dataset.values[tick];\n      sum += value; // This values are used only for animation.\n\n      const animatedValue = value * dataset.alpha;\n      animatedSum += animatedValue;\n      result[index] = {\n        value,\n        animatedValue\n      };\n    });\n    let stackedAnimPercent = 0;\n    datasetsToInclude.forEach((dataset, index) => {\n      result[index].percent = Object(_Utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__[\"roundToDigitsAfterPoint\"])(result[index].value / sum * 100, digits);\n      result[index].animatedPercent = Object(_Utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__[\"roundToDigitsAfterPoint\"])(result[index].animatedValue / animatedSum * 100, digits);\n      stackedAnimPercent += result[index].animatedPercent; // TODO - deal with this rounding.\n\n      result[index].stackedAnimPercent = Object(_Utils_numberUtils__WEBPACK_IMPORTED_MODULE_1__[\"roundToDigitsAfterPoint\"])(stackedAnimPercent, 2);\n    });\n    return result;\n  } // TODO - refactor / move ???\n\n\n  getStackedPercentageValuesForTicks(tickStart, tickEnd, digits = 2) {\n    const datasetsToInclude = this.valueDatasets.filter(d => d.alpha > 0);\n    const result = {};\n\n    for (let tick = tickStart; tick <= tickEnd; tick++) {\n      result[tick] = this.getStackedPercentageValues(tick, datasetsToInclude, digits);\n    }\n\n    return result;\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Data/Data.js?");

/***/ }),

/***/ "./src/Data/DataProvider.js":
/*!**********************************!*\
  !*** ./src/Data/DataProvider.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DataProvider; });\n/* harmony import */ var _Data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Data */ \"./src/Data/Data.js\");\n/* eslint-disable class-methods-use-this */\n\n\nconst twoDigit = number => number < 10 ? `0${number}` : number;\n\nconst buildDataUrl = (dataId, year = null, month = null, date = null) => {\n  if (!year || !month || !date) return `./src/Data/graph_data2/contest/${dataId}/overview.json`;\n  return `./src/Data/graph_data2/contest/${dataId}/${year}-${twoDigit(month)}/${twoDigit(date)}.json`;\n};\n\nconst buildDataUrlFromDailyTimestamp = (dataId, timestamp) => {\n  const date = new Date(timestamp);\n  return buildDataUrl(dataId, date.getFullYear(), date.getMonth() + 1, date.getDate());\n}; // const getJson = (url, onLoaded) => {\n//     const request = new XMLHttpRequest();\n//     request.onreadystatechange = () => {\n//         if (request.readyState === 4 && request.status === 200) {\n//             // TODO - preloaders ????????\n//             // document.body.removeChild(document.getElementById('preloader'));\n//             const data = JSON.parse(request.responseText);\n//             onLoaded(data);\n//         }\n//     };\n//     request.open('GET', url, true);\n//     request.send(null);\n// };\n// Loads data and maps it to instances of Dataset classes.\n\n\nclass DataProvider {\n  loadOverviewData(dataId) {\n    const url = buildDataUrl(dataId);\n    return fetch(url).then(response => {\n      if (response.status === 200) return response.json();\n      throw Error('fetch failed');\n    }).then(json => {\n      console.log(json);\n      return new _Data__WEBPACK_IMPORTED_MODULE_0__[\"default\"](json);\n    }).catch(error => {\n      console.log(error); // TODO - error handler\n    });\n  }\n\n  loadDetailedData(dataId, timestamp) {\n    const url = buildDataUrlFromDailyTimestamp(dataId, timestamp);\n    return fetch(url).then(response => {\n      if (response.status === 200) return response.json();\n      throw Error('fetch failed');\n    }).then(json => new _Data__WEBPACK_IMPORTED_MODULE_0__[\"default\"](json)).catch(error => {\n      console.log(error); // TODO - error handler\n    });\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Data/DataProvider.js?");

/***/ }),

/***/ "./src/Data/Dataset.js":
/*!*****************************!*\
  !*** ./src/Data/Dataset.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Dataset; });\nclass Dataset {\n  constructor(id, name, type, color, values) {\n    this.id = id;\n    this.name = name;\n    this.type = type;\n    this.color = color;\n    this.values = values;\n    this.enabled = true;\n    this.presence = 1; // this property is used for animations.\n\n    this.useAlternateAxis = false;\n  }\n\n  isAxisType() {\n    return this.type === 'x';\n  }\n\n  isValueType() {\n    return this.type !== 'x';\n  }\n\n  getMinMaxValues(startIndex = 0, endIndex = this.values.length - 1) {\n    let min = this.values[startIndex];\n    let max = this.values[startIndex];\n\n    for (let i = startIndex + 1; i <= endIndex; i++) {\n      const value = this.values[i];\n      if (value < min) min = value;\n      if (value > max) max = value;\n    }\n\n    return {\n      min,\n      max\n    };\n  }\n\n}\n\n//# sourceURL=webpack:///./src/Data/Dataset.js?");

/***/ }),

/***/ "./src/Settings/index.js":
/*!*******************************!*\
  !*** ./src/Settings/index.js ***!
  \*******************************/
/*! exports provided: chartValueLabelYOffset, chartTimestampXOffset, chartTimestampYOffset, chartAxisColor, chartAxisLineThickness, chartTextFont, chartTextColor, themeSpecific */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chartValueLabelYOffset\", function() { return chartValueLabelYOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chartTimestampXOffset\", function() { return chartTimestampXOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chartTimestampYOffset\", function() { return chartTimestampYOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chartAxisColor\", function() { return chartAxisColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chartAxisLineThickness\", function() { return chartAxisLineThickness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chartTextFont\", function() { return chartTextFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"chartTextColor\", function() { return chartTextColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"themeSpecific\", function() { return themeSpecific; });\nconst chartValueLabelYOffset = -10;\nconst chartTimestampXOffset = -6 * 0;\nconst chartTimestampYOffset = 12;\nconst chartAxisColor = '#D3D3D3';\nconst chartAxisLineThickness = 1;\nconst chartTextFont = '14px Arial';\nconst chartTextColor = '#A9A9A9';\nconst themeSpecific = {\n  day: {\n    gridLinesColor: '#182D3B',\n    gridLinesAlpha: 0.1,\n    zoomOutText: '#108BE3',\n    tooltipArrow: '#D2D5D7'\n  },\n  night: {\n    gridLinesColor: '#FFFFFF',\n    gridLinesAlpha: 0.1,\n    zoomOutText: '#48AAF0',\n    tooltipArrow: '#D2D5D7'\n  }\n};\n\n//# sourceURL=webpack:///./src/Settings/index.js?");

/***/ }),

/***/ "./src/Settings/mainWindow.js":
/*!************************************!*\
  !*** ./src/Settings/mainWindow.js ***!
  \************************************/
/*! exports provided: valueLineThickness, paddingBottom, axesToDisplay, timestampsToDisplay, padding */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"valueLineThickness\", function() { return valueLineThickness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"paddingBottom\", function() { return paddingBottom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"axesToDisplay\", function() { return axesToDisplay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timestampsToDisplay\", function() { return timestampsToDisplay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"padding\", function() { return padding; });\nconst valueLineThickness = 1;\nconst paddingBottom = 25;\nconst axesToDisplay = 6;\nconst timestampsToDisplay = 5;\nconst padding = {\n  top: 50,\n  left: 25,\n  right: 15 * 0,\n  bottom: 25\n};\n\n//# sourceURL=webpack:///./src/Settings/mainWindow.js?");

/***/ }),

/***/ "./src/Settings/popupWindow.js":
/*!*************************************!*\
  !*** ./src/Settings/popupWindow.js ***!
  \*************************************/
/*! exports provided: yOffset, padding, canvasMinXMargin, alpha, lineThickness, lineColor, dateColor, dateFont, dateYOffset, valueFont, valuesYOffset, nameFont, namesYOffset, captionsInterval, modes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yOffset\", function() { return yOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"padding\", function() { return padding; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canvasMinXMargin\", function() { return canvasMinXMargin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alpha\", function() { return alpha; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineThickness\", function() { return lineThickness; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineColor\", function() { return lineColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dateColor\", function() { return dateColor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dateFont\", function() { return dateFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dateYOffset\", function() { return dateYOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"valueFont\", function() { return valueFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"valuesYOffset\", function() { return valuesYOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nameFont\", function() { return nameFont; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"namesYOffset\", function() { return namesYOffset; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"captionsInterval\", function() { return captionsInterval; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"modes\", function() { return modes; });\nconst yOffset = 35;\nconst padding = 10;\nconst canvasMinXMargin = 5;\nconst alpha = 0.85;\nconst lineThickness = 1;\nconst lineColor = '#D3D3D3';\nconst dateColor = '#000000';\nconst dateFont = 'bold 15px Arial';\nconst dateYOffset = 10;\nconst valueFont = 'bold 16px Arial';\nconst valuesYOffset = 28;\nconst nameFont = '13px Arial';\nconst namesYOffset = 15;\nconst captionsInterval = 15;\nconst modes = {\n  fillStyle: {\n    day: '#FFFFFF',\n    night: '#242F3E'\n  },\n  textColor: {\n    day: '#000000',\n    night: '#FFFFFF'\n  }\n};\n\n//# sourceURL=webpack:///./src/Settings/popupWindow.js?");

/***/ }),

/***/ "./src/Settings/slider.js":
/*!********************************!*\
  !*** ./src/Settings/slider.js ***!
  \********************************/
/*! exports provided: settings */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"settings\", function() { return settings; });\n// eslint-disable-next-line import/prefer-default-export\nconst settings = {\n  padding: {\n    top: 3,\n    left: 0,\n    right: 0,\n    bottom: 3\n  },\n  selectionInitialRange: 0.25,\n  selectionMinRange: 0.20,\n  draggableOffset: 5,\n  draggableWidth: 20\n};\n\n//# sourceURL=webpack:///./src/Settings/slider.js?");

/***/ }),

/***/ "./src/Styles/slider.js":
/*!******************************!*\
  !*** ./src/Styles/slider.js ***!
  \******************************/
/*! exports provided: style, themeDependent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"style\", function() { return style; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"themeDependent\", function() { return themeDependent; });\nconst style = {\n  lineWidth: 1,\n  borderRadius: 10,\n  uiHorBorderWidth: 1,\n  uiVertBorderWidth: 15\n};\nconst themeDependent = {\n  day: {\n    // unselectedAreaColor: '#F5F9FB',\n    // frameColor: '#DDEAF3',\n    scrollBackgroundColor: '#E2EEF9',\n    scrollBackgroundOpacity: 0.6,\n    scrollSelectorColor: '#C0D1E1'\n  },\n  night: {\n    // unselectedAreaColor: '#1F2A38',\n    // frameColor: '#40566B',\n    scrollBackgroundColor: '#304259',\n    scrollBackgroundOpacity: 0.6,\n    scrollSelectorColor: '#56626D'\n  }\n};\n\n//# sourceURL=webpack:///./src/Styles/slider.js?");

/***/ }),

/***/ "./src/Utils/dateFormaters.js":
/*!************************************!*\
  !*** ./src/Utils/dateFormaters.js ***!
  \************************************/
/*! exports provided: getShortDate, getShortDateWithDayOfWeek, getFullDate, getFullDateWithDayOfWeek, getDateForPopup, getHour */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getShortDate\", function() { return getShortDate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getShortDateWithDayOfWeek\", function() { return getShortDateWithDayOfWeek; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFullDate\", function() { return getFullDate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getFullDateWithDayOfWeek\", function() { return getFullDateWithDayOfWeek; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDateForPopup\", function() { return getDateForPopup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHour\", function() { return getHour; });\nconst monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\nconst dayOfWeekNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\nconst monthNamesFull = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\nconst dayOfWeekNamesFull = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nconst getShortDate = timestamp => {\n  const date = new Date(timestamp);\n  return `${monthNames[date.getMonth()]} ${date.getDate()}`;\n};\nconst getShortDateWithDayOfWeek = timestamp => {\n  const date = new Date(timestamp);\n  return `${dayOfWeekNames[date.getDay()]}, ${monthNames[date.getMonth()]} ${date.getDate()}`;\n};\nconst getFullDate = timestamp => {\n  const date = new Date(timestamp);\n  return `${date.getDate()} ${monthNamesFull[date.getMonth()]} ${date.getFullYear()}`;\n};\nconst getFullDateWithDayOfWeek = timestamp => {\n  const date = new Date(timestamp);\n  return `${dayOfWeekNamesFull[date.getDay()]}, ${date.getDate()} ${monthNamesFull[date.getMonth()]} ${date.getFullYear()}`;\n};\nconst getDateForPopup = timestamp => {\n  const date = new Date(timestamp);\n  return `${dayOfWeekNames[date.getDay()]}, ${date.getDate()} ${monthNames[date.getMonth()]} ${date.getFullYear()}`;\n};\nconst getHour = timestamp => {\n  const hours = new Date(timestamp).getHours();\n  return `${hours < 10 ? '0' : ''}${hours}:00`;\n};\n\n//# sourceURL=webpack:///./src/Utils/dateFormaters.js?");

/***/ }),

/***/ "./src/Utils/numberUtils.js":
/*!**********************************!*\
  !*** ./src/Utils/numberUtils.js ***!
  \**********************************/
/*! exports provided: roundToDigitsAfterPoint, formatValue, calculateHorizontalAxisValues */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"roundToDigitsAfterPoint\", function() { return roundToDigitsAfterPoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"formatValue\", function() { return formatValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateHorizontalAxisValues\", function() { return calculateHorizontalAxisValues; });\nconst roundToDigitsAfterPoint = (number, digits) => Math.round(number / 10 ** -digits) / 10 ** digits;\nconst formatValue = (value, percentage) => {\n  if (percentage) return `${roundToDigitsAfterPoint(value, 0)}%`;\n\n  if (value >= 1000 * 1000) {\n    const formattedValue = roundToDigitsAfterPoint(value / 1000000, 2);\n    return `${formattedValue}M`;\n  }\n\n  if (value >= 1000) {\n    const formattedValue = roundToDigitsAfterPoint(value / 1000, 2);\n    return `${formattedValue}K`;\n  }\n\n  if (value >= 1) {\n    return roundToDigitsAfterPoint(value, 1);\n  }\n\n  return roundToDigitsAfterPoint(value, 2);\n};\n\nconst roundValue = value => {\n  if (value >= 1000) {\n    return roundToDigitsAfterPoint(value, 2);\n  }\n\n  if (value >= 1) {\n    return roundToDigitsAfterPoint(value, 1);\n  }\n\n  return roundToDigitsAfterPoint(value, 2);\n};\n\nconst calculateHorizontalAxisValues = (valuesRange, countOfAxisToDraw) => {\n  const range = valuesRange.max - valuesRange.min;\n  let valuesDelta = range / (countOfAxisToDraw - 0.5);\n  if (range < 1000 && valuesDelta > 2) valuesDelta = Math.round(valuesDelta);\n  const values = {};\n\n  for (let i = 0; i < countOfAxisToDraw; i++) {\n    const value = roundValue(valuesRange.min + valuesDelta * i);\n    values[value] = 1;\n  }\n\n  return values;\n};\n\n//# sourceURL=webpack:///./src/Utils/numberUtils.js?");

/***/ }),

/***/ "./src/Utils/textUtils.js":
/*!********************************!*\
  !*** ./src/Utils/textUtils.js ***!
  \********************************/
/*! exports provided: measureText */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"measureText\", function() { return measureText; });\n// eslint-disable-next-line import/prefer-default-export\nconst measureText = (context, text, usedFont) => {\n  context.font = usedFont;\n  return Math.ceil(context.measureText(text).width);\n};\n\n//# sourceURL=webpack:///./src/Utils/textUtils.js?");

/***/ }),

/***/ "./src/clicker.js":
/*!************************!*\
  !*** ./src/clicker.js ***!
  \************************/
/*! exports provided: createClickEffect */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createClickEffect\", function() { return createClickEffect; });\n// eslint-disable-next-line import/prefer-default-export\nconst createClickEffect = (x, y) => {\n  const pulse = document.createElement('div');\n  pulse.className = 'pulseEffect animated';\n  return pulse;\n}; // document.addEventListener('click', (e) => {\n//     const pulse = createClickEffect(e.pageX, e.pageY);\n//     const parent = document.querySelector('#pulsar');\n//     parent.appendChild(pulse);\n//     const ratio = window.devicePixelRatio;\n//     console.log(e);\n//     pulse.style.marginLeft = `${e.pageX - 25 * ratio}px`;\n//     pulse.style.marginTop = `${e.pageY - 25 * ratio}px`;\n// });\n\n//# sourceURL=webpack:///./src/clicker.js?");

/***/ }),

/***/ "./src/constants.js":
/*!**************************!*\
  !*** ./src/constants.js ***!
  \**************************/
/*! exports provided: CHART_TYPES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CHART_TYPES\", function() { return CHART_TYPES; });\n// Supported chart types.\n// eslint-disable-next-line import/prefer-default-export\nconst CHART_TYPES = {\n  LINE_CHART: {\n    doubleAxis: false,\n    sliderEnabled: true,\n    buttonsEnabled: true\n  },\n  DOUBLE_AXIS_LINE_CHART: {\n    doubleAxis: true,\n    sliderEnabled: true,\n    buttonsEnabled: true\n  },\n  STACKED_BAR_CHART: {\n    doubleAxis: false,\n    sliderEnabled: true,\n    buttonsEnabled: true\n  },\n  DAILY_BAR_CHART: {\n    doubleAxis: false,\n    sliderEnabled: true,\n    buttonsEnabled: true\n  },\n  PERCENTAGE_STACKED_AREA_CHART: {\n    doubleAxis: false,\n    sliderEnabled: true,\n    buttonsEnabled: true\n  },\n  UNSUPPORTED_TYPE: {}\n};\n\n//# sourceURL=webpack:///./src/constants.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App */ \"./src/App.js\");\n/* harmony import */ var _clicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./clicker */ \"./src/clicker.js\");\n\n\nwindow.app = new _App__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\nwindow.app.init();\nwindow.app.loadData();\n\nwindow.onresize = () => {\n  window.app.adjustChartsToScreen();\n};\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });